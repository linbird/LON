# 线程管理

## thread对象

* C++11使用thread类来作为存储和管理线程数据的数据结构。
* thead和unique_ptr一样都是独占所有权的，都**只支持移动而不支持拷贝**
* 每一个线程都有一个`std::thread::id`类型来作为唯一标识，可以通过`thread::get_id()和std::this_thread::get_id()`获取。
* 不能以给旧线程合法赋新值的方式来让对象放弃对旧线程的所有权

### 线程创建

* 支持从普通函数指针、lambda表达式、带有operator()函数的类的实例对象(**使用临时变量时注意C++的语法解析**)、类的函数(需提供类的实例化的对象的地址)来创建线程。
* 线程所持有的资源会在线程正常退出的时候自动释放
* 进程内可以创建的线程的数量是有限的，通过`thread::hardware_concurrency()`函数可以获取支持的线程的具体数量。

#### 线程运行方式

1. thread::join():子线程会阻塞主线程的执行，只有当子线程结束后主线程才能继续执行。
2. thread::datach():分离式启动线程，线程不会阻塞主线程的运行，子线程在后台运行，可用于创建守护线程。

## 参数传递

* 线程的参数传递经过了**两个过程（前者是拷贝传值，后置传递右值）**，一是由thread()构造函数传入thread对象的内部，二是由线程对象内部传递给实际执行线程函数参数。
* 只需要将需要传递的参数做为thread构造函数的参数即可实现传参，此时参数会被拷贝到线程对象的内存空间，然后在线程内部以右值的方式传递给线程函数

### **NOTE**

1. thread对象支持用带参数的函数初始化，但是参数中的默认参数会被忽略。
2. 当确实需要以数据的引用方式传递参数时，需要使用std::ref(obj)来生成引用包裹以传递引用类型。
3. 当thread传递不允许拷贝的参数时，可以对原始参数进行move操作以实现参数的正常传递
4. 当参数使用到指针的时候要注意指针所指向的变量的生命周期

# 异常处理

* 通常需要在线程内部的异常处理代码中手动加入thread::join()代码以确保线程在发生意外后任然可以正常结束

# 数据共享

* 多个线运行情况下需要保证只能有一个线程可以看见不变量的中间状态

## 互斥量mutex

* mutex实现了锁用来控制对共享数据的访问，mutex类提供了lock和unlock两个成员方法。
* 推荐使用支持RAII的模板类`lock_guard<mutex>`来实现对互斥量的自动管理。
* C++17的`scoped_lock(mutex_objs)`是C++11中的优化实现。
* **NOTE**:mutex不能保护通过指针或者引用方式访问到的数据，因此切勿将受保护数据的指针或引用传递到互斥锁作用域之外。
