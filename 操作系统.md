# 进程管理

## 进程

* 一个包含线程集和资源集的动态实体（程序运行时的产物），是资源管理及分配的最小单元
* **NOTE**:用户进程同时具备内核空间与用户空间，在进行系统调用时用户进程会由用户内存空间陷入内核内存空间。

## 线程

* 程序执行的最小单元

|                      |             内核线程             |                   用户线程                   |
| :------------------: | :------------------------------: | :------------------------------------------: |
|      OS内核感知      |              可感知              |                    无感知                    |
| 管理主体(建立和销毁) |             操作系统             | 线程库而非内核支持（创建、同步、调度和管理） |
|      处理器分配      | 进程的多个线程可以获得多个处理机 |                   单处理器                   |
|      OS调度单位      |               线程               |       内核调度进程、进程自定义线程调度       |
|        工作态        |            只在内核态            |        用户态和内核态(执行系统调用时)        |

### 内核线程/守护进程

* 每一个内核线程都是内核部分代码的一个运行实体，相当于以一个特化的部分，每个内核线程都有其特定的任务

* 内核为每一个内核线程维护一个内核控制块TCB，通过TCB感知和调度内核线程。

* 内核线程是内核调度的基本单位，是“独立运行在内核空间的标准进程”。每一个内核线程都可以在全系统内进行资源的竞争。

* 内核线程没有自己的地址空间，与内核使用同一张页表

* 以下是一些特殊的内核线程（Linux下）

  * | 内核线程 |                           任务                           |
    | :------: | :------------------------------------------------------: |
    |   init   | 运行文件系统上的一系列”init”脚本，并启动shell进程；pid=1 |
    | kthreadd |    内核的守护线程，在内核正常工作时永远不退出；pid=2     |
    |          |                                                          |

  

#### 轻量级进程
* 建立在内核之上并有内核支持的用户线程,它是内核线程的高度抽象,每一个轻量级进程都与一个特定的内核线程关联。

#### 优点

* 在多处理器系统中，内核能够同时调度同一进程中多个线程并行执行到多个处理器中；
* 如果进程中的一个线程被阻塞，内核可以调度同一个进程中的另一个线程；
* 内核支持线程具有很小的数据结构和堆栈，内核线程之间的切换快、开销小；
* 内核本身也可以使用多线程的方式来实现（如Linux的kswapd线程负责在内存不足时将内存页写回磁盘、kflushd、bpflush线程负责周期性的将脏数据写会磁盘）。

#### 缺点

* 即使CPU在同一个用户进程的多个线程之间切换，也需要陷入内核，因此其速度和效率不如用户级线程。
* 当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态?????????

### 用户线程

* 不需要内核支持而在用户空间中实现的线程，用户进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。其内部的活动对于内核是透明的。

* 多见于一些历史悠久的操作系统，例如Unix操作系统，不需要用户态/核心态切换，速度快，操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。

#### 优点

1. 可以在不支持线程的OS上实现线程
2. 不需要内核干涉，少了进出内核态的消耗，管理（创建、切换、销毁）线程的代价比进程小得多
3. 进程可以定制自己的线程的调度策略，管理灵活度高
4. 能够利用的表空间和堆栈空间比内核级线程多

#### 缺点

1. 同一进程同时只有一个线程运行
2. 进程内的一个线程处于阻塞态会导致整个进程处于阻塞态而被挂起

### 线程实现模型

* 内核态的系统线程专⻔负责执⾏，⽽⽤户态的线程负责存储状态（线程栈状态、寄存器相关的信息、局部变量等）。内核将若干个内核态的线程构成内核态线程池pool，⽤户态只需要创建抽象的专⻔⽤来存储状态的这种⽤户态线程，当用户态线程需要执⾏的时候，将它绑定到⼀个系统线程上由系统线程去执⾏，当执⾏完了以后将系统线程释放回Pool⾥而不需要消灭这个系统线程。[参考来源](https://www.jianshu.com/p/49e3e47d41f0)

#### 用户线程:内核线程 = 1:1

* 一个用户线程在其生命周期内被映射/绑定到一个内核线程、每个用户线程都对应一个内核线程作为调度实体(反过来不一定成立，一个内核线程**不一定有**对应的用户线程)。
* 内核会对每个线程进行调度，所以线程在用户空间的切换就涉及到了多个内核态的线程的切换。
* 创建方法：一般一直使用API或者通过系统调用(Linux:clone、Windows:CreateThread)创建的线程为一对一模型。
##### 优点
1. 一个线程因某种原因阻塞时其他线程的执行不受影响
2. 多线程的程序在多处理机上能够充分利用多个处理机，提高程序的表现。

##### 缺点

1. 内核支持的内核线程数量有限，许多操作系统限制了内核线程的数量。
2. OS在内核线程之间的调度时开销比较大

#### 混合线程模型

* 用户线程库和内核都可以参与线程的管理，用户线程由运行时库调度器管理，内核线程由操作系统调度器管理。
* 准备就绪的用户线程由运行时库分派并标记为可执行，操作系统选择可执行的用户线程并将它映射到线程池中的可用内核线程。

#### **混合线程模型** 用户线程:内核线程 = N : 1

* 将多个用户线程映射到一个内核线程，线程的创建、调度、同步的所有细节全部由进程的用户空间线程库来处理。
##### 优点
1. 对用户线程的数量几乎无限制。
2. 线程之间的切换由用户态的代码来进行，相对一对一模型其线程切换速度要快许多；
##### 弊端

1. 如果其中一个用户线程阻塞将导致其绑定的内核线程阻塞，绑定到该内核线程的其他用户线程也会阻塞。
2. 在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。

#### **混合线程模型** 用户线程:内核线程 = N : M
* 将多个用户线程映射到多个内核线程上。
* 是实现原生协程的关键
##### 优点
1. 一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行；
2. 对用户线程的数量没有限制；

##### 弊端
1. 多处理机下的性能提升不如1:1模型提升大

### 线程调度

### 线程同步（锁）
#### 互斥锁
#### 读写锁
#### 条件变量
#### 自旋锁
#### 内存屏障

## 现代OS下的调度

* 在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换,如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换

## 协程

* 协程更多的是一种暂停的概念。在一个线程中可以通过协调器来暂停继续不同的协程而避免使用线程的上下文切换，从而实现不同协程的交替运行。以上所有操作都在用户态执行，开销小。
### 优点
1. 协程由用户自己进行调度，因此减少了上下文切换，提高了效率。
2. 线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。
3. 由于在同一个线程上，因此可以避免竞争关系而使用锁。
4. 适用于被阻塞的、IO频繁且需要大量并发的场景。

# 内存管理

## 分页管理

## 分段管理

# 文件管理

## 基本概念

### 超级块

* 存放于磁盘的特定扇区中用于存储文件系统的控制信息（文件系统的状态、类型、大小、区块数、索引节点数等）的数据结构。

### 索引节点 INode

* 用于存储文件的元数据（诸如文件的大小、拥有者、创建时间、磁盘位置等和文件相关的信息）的一个数据结构。

### 文件

* 一组在逻辑上具有完整意义的信息项的系列。

## 进程对文件的管理

* 进程通过Task_Struct结构中的files_struct域来了解它当前所打开的文件对象，所谓文件描述符就是文件在进程的已打开的文件对象数组中的下标索引，文件对象通过内部域f_dentry找到文件目录项对象，通过文件对象的f_op域得到该文件支持的标准方法。
* 超级块、Task_Struct等结构的关系如下：![relation](/run/media/linbird/79a60176-120e-4b69-b805-79ebe446d5e9/linbird/Londa/img/OS/relationship.jpg)
mmap()

# Linux Kernel

## 设计哲学

### [一切皆文件](https://cloud.tencent.com/developer/article/1512391)

* 在Linux系统中，由于管道文件、socket文件等特殊文件的存在，一切皆文件退化为**一切皆文件描述符**。
* bash再处理到`/dev/tcp/host/port`的充电向时建立了一个`host:port`的socket连接，将socket的读写表现的和普通文件的读写一样，但是上述的文件在文件系统并不是真实存在的，知识bash对用户的一个善意的谎言。
* plan9系统承诺彻底贯彻执行一切皆文件，将分布在不同位置的所有资源作为文件统一在同一棵目录树中，实现Unix最初的愿景。

## 系统调用

## 虚拟文件系统VFS

* 通过虚拟文件系统VFS提供的抽象层，程序可以用标准的Unix系统调用对不同的文件系统，甚至不同介质上的文件系统进行读写操作。
* 文件IO流程

1. 应用程序通过文件操作函数（`open()、close()、read()、write()、ioctl()`）调用VFS提供的系统调用函数接口(`sys_open()、sys_close()、sys_read()、sys_write()、sys_ioctl()`)同VFS进行交互。
2. VFS通过驱动程序提供的`file_operation`接口同设备驱动进行交互（驱动层的`file_operations`方法的屏蔽了不同类型设备的底层操作方法的差异）

### VFS数据结构

* VFS主要通过四个主要的结构体实现抽象层，每个结构体包含了该结构体支持的方法的一个列表，使其表现的如同对象（数据和方法）。
* VFS中超级块、挂载点以及文件系统的关系![VFS](/run/media/linbird/79a60176-120e-4b69-b805-79ebe446d5e9/linbird/Londa/img/OS/vfs.jpg)

#### 超级块对象

* 存储一个已安装的文件系统的控制信息，代表一个已安装的文件系统;每次一个实际的文件系统被安装时， 内核会从磁盘的特定位置读取一些控制信息来填充内存中的超级块对象。一个安装实例和一个超级块对象一一对应。

#### 索引节点对象

* 存储了文件的相关信息，代表了存储设备上的一个实际的物理文件。当一个文件被访问时，内核会在内存中组装相应的索引节点对象，以便向内核提供对一个文件进行操作时所必需的全部信息;这些信息一部分存储在磁盘特定位置，另外一部分是在加载时动态填充的。

#### 目录项对象

* 为了方便查找文件而创建的对象，

#### 文件对象

* 已打开的文件在内存中的表示，主要用于建立进程和磁盘上的文件的对应关系。文件对象和物理文件的关系类型进程和程序的关系，文件对象仅仅在进程观点上代表已经打开的文件。一个文件对应的文件对象可能不是惟一的，但是其对应的索引节点和目录项对象是惟一的。

#### NOTE

1. Linux支持的文件系统无论是否有文件系统的实例存在，都有且仅有一个`file_system_type`结构用于描述具体的文件系统的类型信息。相同文件系统的多个实例的超级块通过其域内的s_instances成员链接。
2. 每一个文件系统的实例都对应有一个超级块和安装点，超级块通过它的一个域s_type指向其对应的具体的文件系统类型`file_system_type`。

### tmpfs

### sysfs

### debugfs

### procfs

### sockfs

* sockfs实现了VFS中的4种主要对象：超级块super block、索引节点inode、目录项对象dentry和文件对象file，当执行文件IO系统调用时，VFS就将请求转发给sockfs，而sockfs就调用具体的协议实现
* socketfs作为伪文件系统被编译进内核(因为要支持整个TCP/IP协议栈)而非一个模块，它在系统启动到关闭期间总是被装载着的。

### devfs

## 调度管理

### Linux的任务管理

* Linux将所有的执行实体都称之为任务（task）而非OS中的进程。，每一个Task都有其Task_Struct结构来标识该Task，多个Task_Struct可以在域中指明共享的资源空间。
* Linux的每一个Task都具有内存空间、执行实体、文件资源等进程都具有的资源，从表现形式上看类似于一个单线程的进程。
* Linux允许多个任务共享内存空间，从而可以使多个任务运行在同一个内存空间上。从表现上来看，此时的多个任务相当于多个线程，多个这样的线程构成了一个进程。

### Linux线程

* Linux将所有的运行的实体都视为Task，所以Linux的线程并非教科书意义上的线程而是一种Task，是一种用来**实现进程资源共享**的一种方式。
* 在linux2.6之前，内核并不支持线程的概念，仅通过轻量级进程（lightweight  process）模拟线程，一个用户线程对应一个内核线程（内核轻量级进程），这种模型最大的特点是线程调度由内核完成了，而其他线程操作（同步、取消）等都是核外的线程库（LinuxThread）函数完成的。[参考来源](https://developer.aliyun.com/article/374623)
* 在linux2.6之后，为了完全兼容posix标准，linux2.6对内核进行改进，引入了线程组的概念（仍然用轻量级进程表示线程），有了这个概念就可以将一组线程组织称为一个进程，如此通过这个改变，linux内核正式支持多线程特性。在实现上主要的改变就是在task_struct中加入tgid字段，这个字段就是用于表示线程组id的字段。在用户线程库方面，也使用NPTL代替LinuxThread。[参考来源](https://developer.aliyun.com/article/374623)

#### 共享的资源
* 内存地址、空间进程基础信息、大部分数据、打开的文件、信号处理、当前工作目录用户和用户组属性等
#### 线程独有
* 线程ID、寄存器、栈的局部变量、返回地址、错误码errno、信号掩码、优先级等


### 多线程编程模式
#### leader-follow 模型（主从）
#### producer-consumer模型（生产者消费者）
#### 高并发索引模型

### 相关问题
1. 为什么线程切换的代价比进程切换小？
* 因为本质上，线程很多资源都是共享进程的，所以切换时，需要保存和切换的项是很少的。比如线程切换时，同一个进程的多个线程的虚地址空间是不变的，而进程的切换需要OS切换虚地址空间、重新建立虚实地址空间的映射、刷新CPU的TLB、旧的cpu缓存在新的进程中将失效，新缓存的建立和开始一段时间的访存将会比较慢。