# Redis

## 数据结构

### key

**非二进制安全**的字符串类型，其值不能太长且可读性要强，

```c
//查询
keys pattern  //返回匹配的key
randomkey  //从当前数据库随机返回一个key
type key  //返回key数据类型
exists key  //检查key是否存在


//删除，修改
flushdb //删除当前库中的key
flushall //删除所有库中的key
delkey [key...]  //删除某个或者多个key-value
move key num  //将当前数据库中的key移到数据库num中
rename key newkey //改名，newkey存在时则将会覆盖
renamenx key newkey  //当且仅当newkey不存在的时候才执行

//时间相关
expire key second  //设置key的过期时间、秒
expireat key timestamp  //设置key的过期时间、时间戳
pexpire key milliseconds  //设定多少毫秒内过期
pexpireat key timestamp-milliseconds  //设置为时间戳，毫秒级
ttl key  //查看给定键距离过期时间还有多少秒
pttl key  //查看给定键距离过期时间还有多少毫秒
persist key  //移除过期时间

//返回查询key的属性
object refcount|encoding|idletime key  //返回key，引用次数|内部存储编码|空转时间
#可编为多种方式编码：
#1、字符串可存为raw（一般字符串）、int（小数字）
#2、列表可存为ziplist、linkedlist
#3、集合可存为inset（数字小集合）、hashtable
#4、散列可存为zipmap（小散列）、hashtable
#5、有序集合可存为ziplist（小有序集合）、skiplist（任何大小）

//排序
sort source-key [by pattern] [limit offset count] [get pattern…] [asc|desc] [alpha] [store dest-key]
#1、source-key：排序的key
#2、by pattern：表示可以通过外部权重进行排序（即外部key，需要与排序key有关联）。例如：链表key为list-userid（1,2,3,4…），则外部key名为，goods_1、goods_2…，则by pattern为（by goods_*）
#3、limit offset count：表示排序后返回的数据行
#4、get pattern…：获取外部数据（参数与by pattern一样）
#5、asc|desc：升序|降序
#6、alpha：采用字符排序，默认是数字排序
#7、store dest-key：表示将结果存入dest-key中
```

### value

#### `string`

**二进制安全**的字符串类型，`string`**可以包含任何数据**（图片或者序列化的对象），最大**上限是1GB**。 

```c
strlen key  //字符串长度

//写
set key value //设置key-value对/
mset key1 value1 key2 value2...//同时写多个
setnx key value  //当且仅当key不存在时才设置
setrange key-name offset value  //将value代替从offset开始的字符串,超过的长度使用0代替

//读
get key  //获取key值
getset key value  //获取旧值设置新值
mget key1 key2...//同时读多个
setex key seconds value  //设置k-v对时并且设置过期时间
getrange key-name start end  //返回次字符串的start到end之间的字符

//修改
append key value  //追加值
incr、decr、incrby、decrby、incrbyfloat  //对值作运算

//比特位操作
getbit key-name offset  //将字符串看做是二进制位串，并返回位串中的偏移量offset的二进制位的值
setbit key-name offset value  //将字符串看做是二进制位串，并将位串中偏移量offset的二进制值设置为value
bitcount key-name [start end]  //统计二进制位串里面值为1的数量
bitop and|or|xor|not dest-key key1 key2…  //对多个key执行并或异或非，并将结果存入到dest-key
```

#### `list`

按插入顺序排序的字符串链表，允许用户从序列两端推入或者弹出元素，在插入时，**如果该键并不存在，Redis将为该键创建一个新的链表。如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除**。

```c
llen key-name  //返回key-name链的长度

//插入
lpush/rpush key element //将element插入到列表key的头部/尾部，不存在则创建
lpushx/rpushx key element //当key存在时才将element插入到列表key的头部/尾部
lset key index value  //将key中下标为index更新值为value。index超过则报错
linsert key befort|after val value  //在key中位于val值前或者后，插入value值。key或者val不存在，则返回错误

//删除
lpop/rpop key // 将key-element从列表头部/尾部移除
lrem key count value  count=0 // 删除全部一样的；count>0从左边检索删除count个；count<0从右边检索，删除count个
ltrim key-name start end  //保持start到end所有元素，其他删除

//查找
lrange key start end  //返回偏移量中的值，负数为倒数
lindex key offset  //返回偏移量为offset中的值，负数为倒数

//超时操作
blpop/brpop key-name[key-name2…] timeout  //多少秒内阻塞并等待可弹出元素出现

rpoplpush key-name1 key-name2  //从key-name1中弹出最右边的元素，推入key-name2最左边，并返回value元素
brpoplpush key-name value timeout  //阻塞式
```

#### `hash`

```c
hlen key  　　//返回散列包含键值对的数量

//写
hset key field value  　　//设置散列值
hsetnx key field value  //当且仅当field不存在时设置
hmset key field value field2 value2….  //设置多个

//读
hget key field  　　　　　　//获取值
hmget key field field2…  //获取多个
hgetall key  　　//由于redis是单线程操作，假若hgetall返回的数据量大耗时大，将会导致其他客户端的请求得不到响应

//删
hdel key field field2… 　　// 删除一个或者多个值

//查
hexists key-name filed  //检查field是否存key-name中
hkeys key/hvals key  //返回key中的field、返回key中的value

//数值操作
hincrby key-name field num  //给key-name中field的值（必须是数字）增加num
hincrbyfloat key-name key incre
```

#### `set`

通过**hash表实现string类型元素的不重复无序集合**

```c
scard key  //返回集合里包含的元素数量

//增
sadd key member[member2…]  //添加一个或者多个member

//删
srem key member[member2…]  //移除一个或者多个member
spop key  //随机移除集合中的一个元素，并返回
smove key-name1 key-name2 value  //将value元素从key-name1中移到key-name2中

//查
smembers key  //返回key中所有的member
sismember key member  //判断member是否在key中
srandmember key  //随机返回一个member，不删除
srandmember key-name n  //随机返回集合里的n个元素。n负数可重复，正数不出现重复

//集合操作
sdiff key-name1 [key-name2…]  //差集
sdiffstore dest-key key-name1[key-name2...] //差集存入dest-key中
sinter key-name1[key-name2…]  //返回交集
sinterstore dest-key key-name1[key-name2...]  //交集存入dest-key中
sunion key-name1[key-name2…]  //返回并集
sunionstore dest-key key-name1[key-name2…]  //并集存入dest-key中
```

#### `zset`

**string类型的元素构成的不重复有序集合**，为了有序需要将每个元素**给定分数属性**，排序时先按照分数后按照字典序排序。

```c
zcrad key  //返回有序集合里的成员数量

//增
zadd key score member //给有序集合key添加member

//删
zrem key member[member2…]  　　//移出一个或者多个成员
zremrangebyrank key-name start stop   //移出所有有序集合排名介于start和stop之间的元素
zremrangebyscore key-name min max   //移出所有有序集合score介于min和max之间的元素

//查询
zcount key-name min max  　　//返回分值介于min和max之间的成员数量
zscore key member  　　　　//返回成员的分值

//分值操作
zincrby key increment member  　　//将member成员分值加上increment
zrange key start stop [withscores]  　　//成员按分值从小到大排列，返回有序集合给定排名范围
zrevrange key start stop [withscores]  　　//成员按分值从大到小排列，返回有序集合给定排名范围

//基于分值的查询
zrank key member  　　//分值从小到大排序，返回member有序集合的排名
zrevrank key member  //分值从大到小排序，返回member有序集合的排名
zrangebyscore key-name min max [withscores][limt offset count]   　　//返回有序集合中介于min和max之间的所有成员、从小到大
zrevrangebyscore key-name max min [withscores][limt offset count]   //返回有序集合中介于max和min之间的所有成员、从大到小

zinterstore dest-key key-count key-name1[key-name2…] [weights weight1 weight2…] [aggregate sum|min|max]   //先对应分值乘以weights，再取交集，分值对应aggregate，默认sum。结果存入dest-key中
zunionstore dest-key key-count key-name1[key-name2…] [weights weight1 weight2…] [aggregate sum|min|max]
```

## CLI

### 服务相关

```c
select db_index  //选择数据库，一共有16个数据库，默认在数据库0
dbsize  //返回当前数据库key数量
quite  //关闭与服务器连接退出客户端
ping  //用于测试与服务器端连接是否生效，返回pong
echo message  //打印消息，测试用
info //获取统计信息
monitor //监视
config get|set|resetstat|rewrite //获取/修改配置信
```

## 事务

## 持久化

### Snapshotting(快照)

每隔一段时间将数据集转存到磁盘上

```shell
save x y#x秒内有超过y个key被更改就启动快照写入二进制文件中
```



### Append-only file(AOF)

在日志尾部追加每一条操作命令

```shell
```

https://blog.csdn.net/a147bb/article/details/106813604

https://www.cnblogs.com/yuhangwang/p/5817930.html