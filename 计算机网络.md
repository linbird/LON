
<!-- vim-markdown-toc GFM -->

+ [其它](#其它)
    * [URI与URL](#uri与url)
    * [MSS/Maximum Segment Size](#mssmaximum-segment-size)
    * [MTU/Maximum Transport Unit](#mtumaximum-transport-unit)
+ [概览](#概览)
    * [OSI七层模型](#osi七层模型)
    * [TCP/IP四层模型](#tcpip四层模型)
    * [实际五层结构](#实际五层结构)
+ [应用层](#应用层)
    * [SSH](#ssh)
    * [HTTP](#http)
        - [重要演化](#重要演化)
        - [方法](#方法)
        - [状态码](#状态码)
        - [补丁](#补丁)
            + [应对无状态:Cookie;Session;HTTP/1.1持久连接](#应对无状态cookiesessionhttp11持久连接)
            + [分块传输](#分块传输)
            + [管道传输](#管道传输)
        - [其他](#其他)
            + [Token抵御CSRF(跨站请求伪造)攻击](#token抵御csrf跨站请求伪造攻击)
    * [HTTPS(HTTP over TLS)](#httpshttp-over-tls)
        - [实现](#实现)
            + [混合加密](#混合加密)
            + [数字摘要](#数字摘要)
            + [数字签名](#数字签名)
        - [数字证书](#数字证书)
            + [验证过程](#验证过程)
        - [缺点](#缺点)
    * [DNS](#dns)
        - [传输方式](#传输方式)
            + [UDP:53](#udp53)
            + [TCP:53(特殊情况使用)](#tcp53特殊情况使用)
        - [查询过程](#查询过程)
            + [递归解析(常见、默认)](#递归解析常见默认)
            + [迭代解析](#迭代解析)
            + [解析记录](#解析记录)
            + [迭代与递归](#迭代与递归)
        - [DNS的安全问题](#dns的安全问题)
            + [DNSSEC](#dnssec)
            + [DNSCrypt](#dnscrypt)
            + [DNS over TLS（DoT）](#dns-over-tlsdot)
            + [DNS over HTTPS（DoH）](#dns-over-httpsdoh)
        - [NOTE](#note)
    * [DHCP (UDP)](#dhcp-udp)
        - [工作过程](#工作过程)
        - [缺点](#缺点-1)
    * [FTP](#ftp)
        - [工作模式(服务器的主被动)](#工作模式服务器的主被动)
            + [主动](#主动)
            + [被动](#被动)
    * [QUIC](#quic)
+ [传输层](#传输层)
    * [SSL->TLS](#ssl-tls)
        - [过程](#过程)
        - [证书信任链](#证书信任链)
        - [数字证书与服务器一一对应](#数字证书与服务器一一对应)
    * [TCP](#tcp)
        - [三次握手(建立连接)](#三次握手建立连接)
            + [过程](#过程-1)
            + [原因/优点](#原因优点)
            + [其他问题](#其他问题)
        - [可靠传输](#可靠传输)
            + [超时重传](#超时重传)
            + [自动重传(ARQ,auto repeat request)](#自动重传arqauto-repeat-request)
        - [滑动窗口机制](#滑动窗口机制)
        - [拥塞控制](#拥塞控制)
            + [慢开始](#慢开始)
            + [拥塞避免(加性增、乘性减)](#拥塞避免加性增乘性减)
            + [快重传](#快重传)
            + [快恢复](#快恢复)
            + [TCP拥塞控制扩展](#tcp拥塞控制扩展)
        - [流量控制](#流量控制)
        - [流量控制与拥塞控制](#流量控制与拥塞控制)
        - [四次挥手(正常断开连接)](#四次挥手正常断开连接)
            + [过程](#过程-2)
            + [原因/优点](#原因优点-1)
        - [断开连接(客户端故障：保活计时器+探测报文)](#断开连接客户端故障保活计时器探测报文)
    * [UDP/User Datagram Protocol](#udpuser-datagram-protocol)
+ [网络层](#网络层)
    * [ARP/RARP协议](#arprarp协议)
    * [IP](#ip)
        - [IP数据报](#ip数据报)
        - [划分子网](#划分子网)
        - [广播(仅用于UDP)](#广播仅用于udp)
        - [多播/组播(仅用于UDP)](#多播组播仅用于udp)
    * [NAT](#nat)
    * [ICMP/IGMP](#icmpigmp)
        - [ICMP](#icmp)
        - [IGMP](#igmp)
    * [VPN 虚拟专用网](#vpn-虚拟专用网)
    * [ARP/RARP](#arprarp)
    * [路由协议 ??????????????????不完整？？？？？？？？？？？？？](#路由协议-不完整)
        - [内部网关协议](#内部网关协议)
            + [RIP (应用层协议)](#rip-应用层协议)
            + [OSPF 开放最短路径优先](#ospf-开放最短路径优先)
        - [外部网关协议](#外部网关协议)
            + [BGP](#bgp)
+ [数据链路层](#数据链路层)
    * [基本问题](#基本问题)
        - [封装成帧](#封装成帧)
        - [透明传输](#透明传输)
        - [差错检测](#差错检测)
    * [广播信道下的信道利用](#广播信道下的信道利用)
        - [信道复用](#信道复用)
            + [频分复用](#频分复用)
            + [时分复用](#时分复用)
            + [统计时分复用](#统计时分复用)
            + [波分复用](#波分复用)
+ [物理层](#物理层)
+ [套接字](#套接字)
    * [socket文件与Linux设计哲学](#socket文件与linux设计哲学)
    * [套接字类型](#套接字类型)
        - [本地套接字 Unix Socket](#本地套接字-unix-socket)
        - [网络套接字 BSD Socket](#网络套接字-bsd-socket)
    * [套接字实现](#套接字实现)
        - [sockfs文件系统](#sockfs文件系统)
        - [socket初始化](#socket初始化)
        - [socket创建](#socket创建)
        - [socket操作](#socket操作)
        - [socket销毁](#socket销毁)
+ [重要系统调用](#重要系统调用)
    * [socket()](#socket)
    * [bind()](#bind)
    * [listen()](#listen)
    * [connect()](#connect)
    * [accept()](#accept)
    * [close()](#close)
+ [IO模型](#io模型)
    * [阻塞式IO](#阻塞式io)
    * [非阻塞是IO](#非阻塞是io)
    * [IO多路复用/事件驱动](#io多路复用事件驱动)
        - [Posix:select](#posixselect)
            + [优点](#优点)
            + [缺点](#缺点-2)
        - [BSD:kqueue](#bsdkqueue)
        - [Linux:poll](#linuxpoll)
            + [优点](#优点-1)
            + [缺点](#缺点-3)
        - [Linux:epoll（高效）](#linuxepoll高效)
            + [工作模式](#工作模式)
                * [边缘触发ET(高速)](#边缘触发et高速)
                * [电平触发LT(默认)](#电平触发lt默认)
            + [优点](#优点-2)
    * [信号驱动IO(不常用)](#信号驱动io不常用)
    * [异步IO](#异步io)
        - [Windows:IOCP](#windowsiocp)
+ [IO模式](#io模式)
    * [Reactor](#reactor)
        - [步骤](#步骤)
    * [Proactor](#proactor)
        - [步骤](#步骤-1)

<!-- vim-markdown-toc -->

# 其它

## URI与URL

+ URI:Identifier，标识符
+ URL:Location，定位符

## MSS/Maximum Segment Size

+ 最大消息长度：TCP连接中发送的数据包的单位，理想情况下不会被IP层分片。其长度由双方协商(TCP首部的MSS选项)

## MTU/Maximum Transport Unit

+ 最大传输单元：

| 协议  | 端口 | 备注 |
| :---: | :--: | :--: |
|  FTP  |      |      |
| HTTPS |      |      |
|  SSH  |      |      |
| DHCP  |      |      |

# 概览

## OSI七层模型

+ 应用层，会话层，表示层，传输层，网络层，数据链路层，物理层

## TCP/IP四层模型

+ 应用层，运输层，网际层，网络接口层

## 实际五层结构

# 应用层

## SSH

## HTTP

+ 概览:无状态，无连接(每次请求需要建立TCP连接)，明文(无身份确认、无完整性保护)，基于请求和响应，支持任意类型

### 重要演化

+ HTTP/1.0:增加PUT、DELETE等方法
+ HTTP/1.1:长连接/持久链接，管道
+ HTTP/2.0:多路复用，服务器推送

1. 多路复用：通过单一的HTTP/2连接请求发起多重的请求-响应消息，多个请求stream共享一个TCP连接，实现多留并行而不是依赖建立多个TCP连接。

+ HTTP/3.0:

### 方法

1. GET/查：查询，参数可以放入URL中(长度受浏览器限制)。该方法在再次访问网站中未改变的页面时可以使客户端使用缓存而节省流量(通过请求时的If-Modified-Since选项和响应时的状态码304 Not Modified实现)。
2. POST/增：提交，数据放在报文内部
3. PUT/改：
4. DELETE/删：

### 状态码

| 错误码 |            含义            |
| :----: | :------------------------: |
|  1XX   |           信息类           |
|  2XX   |           成功类           |
|  3XX   |          重定向类          |
|  301   |          永久转移          |
|  302   |          临时跳转          |
|  4XX   |        客户端错误类        |
|  400   |          请求错误          |
|  401   |          未经授权          |
|  404   |         资源不存在         |
|  5XX   |        服务端错误类        |
|  500   | 服务器内部发生不可预期错误 |
|  503   |   服务器当前不能处理请求   |

### 补丁

#### 应对无状态:Cookie;Session;HTTP/1.1持久连接

1. Cookie(用户通行证): 服务端生成Cookie传输并保存在客户端上，安全性差，如登录认证场景。
2. Session(用户唯一标识):服务端生成Session对象保存在服务端，用SeesionID标识此对象，此SessionID会随Cookie传输到客户端。安全性高，如保存用户购物车。**Session的实现依赖于Cookie**
3. 持久连接
    + 客户端和服务端在各自的头中加入Connection: Keep-Alive，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。可以自定义连接重用的次数和保持时间。
    + 长连接并不能强制保证连接是活跃的，他能保证当连接被关闭时可以得到一个通知。
    + 结束传输：Content-Length指示大小；对于使用分块/chunked传输的动态生成文件则根据chunked编码判断（最后为一个空的chunked）。
4. URL重写：在URL结尾添加一个附加数据以标识该会话
5. 隐藏表单域：将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示

#### 分块传输

+ 消息体由数量未定的块组成，并以最后一个大小为0的块为结束。
+ 使用方法：HTTP消息头的Transfer-Encoding字段(标示报头将以何种方式进行传输)的值为chunked
+ chunked 的优势在于服务器端可以边生成内容边发送，无需事先生成全部的内容。HTTP/2 不支持 Transfer-Encoding: chunked，因为 HTTP/2 有自己的 streaming 传输方式

#### 管道传输

1. 背景：默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。
2. 作用：通过借助持久连接的机制实现请求的批量提交而不必等待响应后在提交。
3. Note：

+ 只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制。
+ 管线化不会影响响应到来的顺序。
+ HTTP/1.1标准仅仅要求服务器在处理管道传输的响应时不出错，不强制要求响应也要管线化，因此不一定能提升性能，所以Chrome和Firefox默认不提供管线化支持。

### 其他

#### Token抵御CSRF(跨站请求伪造)攻击

+ 原理：斩断攻击者推测合法请求的途径
+ 实现：

1. 参数加密编码
2. 添加随机参数Token(随机性、一次性、注意保密)

## HTTPS(HTTP over TLS)

+ 概览：HTTP+SSL/TLS,主要目的是提供对**服务器**的身份认证，同时保护交换数据的隐私与完整性。

### 实现

#### 混合加密

+ 过程：客户端和服务端首先协商好双方加密的方法，服务端发给客户端自己的数字证书(机构颁发或者自己制作)，客户端验证证书的效力(自己制作的需客户端手动验证)。验证证书后科客户端根据前面的协商过程生成会话密钥，随后使用服务端的公钥加密(非对称加密)会话密钥传输给服务端，服务端以私钥解密出会话密钥。随后双方以协商好的会话密钥传输数据(对称加密)。
+ 原因：非对称加密资源需求高，服务器无法支持大量的连接

#### 数字摘要

+ 通过单向哈希函数对原文(明文)生成固定长度的摘要，？？？？可以比较解密出来的原文的哈希结果和摘要是否一致来防止篡改？？？？

#### 数字签名

### 数字证书

+ 内容:服务器的公钥、权威机构的信息、服务器域名?????(与下文矛盾)。

#### 验证过程

1. 客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。
2. 然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。

### 缺点

1. HTTPS协议多次握手，延长了页面加载时间
2. SSL证书要钱，SSL的算法耗费资源

## DNS

+ 分布式(每个服务器只保存自己的那部分数据)多层级(根->顶级->权威(二级、三级) <->本地>)的域名-IP转换数据库。
+ DNS中共有13个根域名服务器**集群**

### 传输方式

#### UDP:53

1. 广泛使用的传输方法，具有较高的传输效率
2. 通信双方需要必须自己处理超时和重传从而保证可靠性。

#### TCP:53(特殊情况使用)

1. 响应数据大于512B(UDP数据部分上限)
2. 区域传送(主域名服务器向辅助域名服务器传送变化的那部分数据)

### 查询过程

1. 客户端查询本机缓存(浏览器->系统)->hosts文件->本地DNS服务器(自己指定的，114、运营商的都属于)

#### 递归解析(常见、默认)

+ **本地域名服务器**代替DNS客户端查询，本地DNS服务器得到正确结果后将结果返回给客户端。

1. 本地DNS服务器首先尝试以自身缓存的记录响应客户端。
2. 本地记录查询失败就将DNS请求以自身身份向**根服务器**请求响应。
3. 本地域名服务器收到被要求服务的服务器响应的响应报文
    1. 如果响应报文包含最终的映射记录就返回给DNS客户端。
    2. 否则，向响应报文中指示的下一级服务器发送自己的查询请求重复3。

#### 迭代解析

+ 所有查询由**DNS客户端自身**完成
+ 启用条件：客户端向本地DNS服务器的请求中未要求递归查询或者本地DNS服务器不支持递归查询。

1. 本地DNS服务器首先尝试以自身缓存的记录响应客户端。
2. 如果本地DNS服务器查询失败，就向客户端返回响应报文(包含根域名服务器的信息)
3. DNS客户端解析收到的DNS报文
    1. 如果报文包含最终的地址映射就结束
    2. 否则DNS客户端将请求发送到响应报文中所指示的下一级域名服务器上，重复3

#### 解析记录

| 解析类别 |                          含义                           |
| :------: | :-----------------------------------------------------: |
|   A<w>   |               <带权重的>域名与其IPV4地址                |
| AAAA<w>  |               <带权重的>域名与其IPV6地址                |
|  CNAME   |       别名记录，允许将多个名字映射到同一台计算机        |
|    NS    | 域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析 |
|    MX    |            邮件交换记录，指向一个邮件服务器             |
|   PTR    |                  反向DNS，主要用于邮件                  |

#### 迭代与递归

1. 所谓递归指的是查询者的身份发生改变
2. 递归查询返回的结果只有两种:查询成功或查询失败；迭代查询/重指引返回最佳的查询点或者主机地址.
3. 从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询

### DNS的安全问题

+ DNS查询采用明文通讯；客户端默认选择最先收到的DNS响应，而不对结果的有效性和正确性做校验

#### DNSSEC

1. 在DNS请求包的头部加入了一段数字签名保证DNS查询结果的完整性，但没有对DNS查询内容进行加密。

#### DNSCrypt

1. 对DNS查询过程做了完整的加密，保证查询完整和第三方不可见，但未纳入标准

#### DNS over TLS（DoT）

1. 853端口

#### DNS over HTTPS（DoH）

1. 基于HTTPS，工作在应用层，443端口

### NOTE

1. 理论上，全部域名查询都必须先查询根域名，由于只有根域名才能告诉你，某个顶级域名由哪台服务器管理。
2. 因为根域名列表不多变化，大多数 DNS 服务商都会提供它的缓存（通常为1000小时），因此根域名的查询事实上不是那么频繁。

## DHCP (UDP)

+ 作用:自动化配置IP、掩码、网关以及DNS

### 工作过程

1. 客户端发送Discover报文:src=0.0.0.0:68，dst=255.255.255.255:67。将该UDP报文在局域网内广播，如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。
2. 所有收到Discover的DHCP服务端如果可以提供地址就发送offer信息(包含所有预分配的配置信息)，否则送DHCP-NAK报文。
3. 客户端选择一个响应报文准备作为自己的配置，并以**广播**发送Request报文(包含被选择的DHCP服务器的IP地址信)。
4. 收到Request报文的服务端回复ACK报文，允许客户端使用他提供的信息
5. 客户端以广播的方式发送ARP报文，探测是否有主机使用服务器分配的IP地址
    1. 如果在规定的时间内没有收到回应，客户端才使用此地址。
    2. 否则，客户端会发送DHCP-DECLINE报文给DHCP服务器，通知DHCP服务器该地址不可用，并重新申请IP地址
6. 重新登录:直接发送包含前一次所分配的IP地址的DHCP request请求信息，可用就用，不可用就从1 重新开始
7. 更新租约:DHCP客户机启动时和IP租约期限过一半时，DHCP客户机都会自动向DHCP服务器发送更新其IP租约的信息

### 缺点

1. DHCP不能发现网络上非DHCP客户机已经在使用的IP地址；
2. 当网络上存在多个DHCP服务器时，一个DHCP服务器不能查出已被其它服务器租出去的IP地址；
3. DHCP服务器不能跨路由器与客户机通信，除非路由器允许BOOTP转发。

## FTP

+ 使用两个端口(控制/数据)共同完成任务

### 工作模式(服务器的主被动)

#### 主动

+ 服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机
+ 要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。

#### 被动

+ 客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机
+ 服务器开放过多端口导致服务器端的安全性减弱

## QUIC

# 传输层

## SSL->TLS

+ 基础：非对称加密

### 过程

+ 分别确定密钥交互算法、对称加密算法、消息认证算法

1. C->S:ClientHello、TLS版本、支持的加密和压缩算法、ClientRandom字符串
2. S->C:ServerHello、TLS版本、Server选择的算法，自己的证书(含公钥)、ServerRandom字符串。
3. C:根据自己信任的CA列表验证证书，可信则使用Server的公钥加密一段自己生成的随机数"premaster secret (预主密钥)"。
4. C->S:传输公钥加密后的随机数"premaster secret (预主密钥)"
5. S:使用私钥解密随机数，使用ClientRandom、ServerRandom和premaster secret通过之前协商的算法生成自己的共享对称主密钥KEY。
6. C->S:将Finish消息使用KEY加密后传输到服务端
7. S->C:
8. 完成，此后使用对称秘钥交互

### 证书信任链

+ 即一个证书要依靠上一级证书来证明自己是可信的，最顶层的证书被称为根证书，拥有根证书的机构被称为根CA。
+ 验证时需要保证证书的正确性以及证书和域名的对应。
+ 证书信任链最终依赖根CA，根证书一般是操作系统自带（Firefox 浏览器通常是使用自带的一套证书信任机制，不受系统证书的影响）。

### 数字证书与服务器一一对应

+ TLS握手阶段客户端发送的信息之中不包括服务器的域名，当一个服务器有多个网站时会分不清应该向客户端提供哪一个网站的数字证书。
+ 改进:2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。

## TCP

+ 概述：面向连接、面向字节流(把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块)、全双工、一对一的可靠传输协议

### 三次握手(建立连接)

+ 目的：连接服务器指定端口，建立 TCP 连接并同步连接双方的序列号和确认号，交换TCP窗口大小信息，让双方都确认对方和自己的接收和发送功能是正常的。

#### 过程

1. Client ===> Server:SYN、ack=随机序列号seq1。进入SYN_SENT状态
2. Server ===> Client:ACK、seq=seq1+1、SYN、ack=随机序列号seq2，进入SYN_RCVD状态。未收到响应就重发5次ACK+SYN后进入CLOSED状态。
3. Client ===> Server:ACK、seq=seq2+1。检查seq1的回应后回应进入ESTABLISHED状态，服务端动作相同。

+ ![状态转移图](img/network/tcp-establish.png)

#### 原因/优点

1. 两次：可能会出现已失效的连接请求报文段(在网络中滞留时间过长)又传到了服务器端致使服务器建立无用连接，其次，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。
2. 四次：可以但没必要(四次：第二次拆解为两次)

#### 其他问题

1. 随机序列号:避免同一个套接字上建立的多次连接传送的数据混淆(网络中某个包的整体传输时间过长时)。

### 可靠传输

+ 依赖校验和，确认和重传机制

#### 超时重传

+ 若一个已经发送的报文段在超时时间内($RTO_i = RTTs_i+4*RTTd_i = (1-a)RTTs_{i-1} + aRTT + 4RTTd_i$)没有收到确认，就重传这个报文段。TCP在超时重传失败后其超时时间的确定采用二进制指数退避算法。

#### 自动重传(ARQ,auto repeat request)

+ 主要应用在无线链路层

1. 停等式（stop-and-wait）:发完一个就停止，确认后再发下一个
2. 回退n帧（go-back-n）:维持一个发送窗口,不用确认就能发，对last one确认，失败需要回退N
3. 选择性重传（selective repeat）:当发送方接收到接收方的状态报告指示报文出错，发送方只发送传送发生错误的报文。

### 滑动窗口机制

+ 滑动窗口存在于发送端和接收端，窗口内为当前可以被发送或接受的所有消息。

1. 发送方窗口：在滑动窗口内的数据才能被传送，窗口的两边分别是已发送但未确认或者未发送(只会出现在一侧)的数据，重传时可以直接从滑动窗口中取数据。
2. 接收方窗口：作为接收方对数据存储的一个缓冲区，它只对最后一个按序到达的字节进行确认，确认后滑动窗口移动以接受新的数据。

### 拥塞控制

+ 目的与方法：防止过多数据注入网络(传输失败会重传，导致拥塞加重)，导致网络过载。
+ ![拥塞控制概览](img/network/tcp-flow-control.png)

#### 慢开始

cwnd以1为初始值，在未到ssthresh(>=2)之前每次成功传输后，cwnd增长为原来的两倍，传输失败就令ssthresh=cwnd/2。

#### 拥塞避免(加性增、乘性减)

当cwnd>ssthresh时，进入拥塞避免，每个成功传输轮次后swnd=cwnd+1，当出现超时令ssthresh = cwnd/2，cwnd从1开始重复满开始和拥塞避免的过程。

#### 快重传

接收方只对最后一个收到的**有序报文段**进行确认，接收方在收到一个失序的报文段后就立即发出重复确认**而不要等到自己发送数据时捎带确认**(可以使发送方及早知道有报文段没有到达对方)，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而**不必等待设置的重传计时器**时间到期。

#### 快恢复

当发送方连续收到三个重复确认时，令ssthresh=cwnd/2，cwnd=ssthresh <+3*MSS>，**直接进入拥塞避免**(在这种情况下，只是丢失个别报文段，而不是网络拥塞)。

#### TCP拥塞控制扩展

1. 基于丢包的拥塞控制：Tahoe、Reno、New Reno
2. 基于时延RTT的带宽预测：vegas
3. 基于丢包和RTT：westwood
4. 二分搜索最佳cwnd：BIC-TCP
5. 连续拥塞间隔：CUBIC
6. 基于精准带宽计算：BBR

+ BBR摒弃了丢包和实时RTT作为拥塞控制因素。引入BDP管道容量来衡量链路传输水平。BBR追求的是在链路最小RTT（物理链路延迟）的状态下，找到最大带宽。

### 流量控制

+ 目的与方法：通过改变滑动窗口大小控制发送方发送速率
+ 滑动窗口
  1. 滑动窗口<=min(拥塞窗口、接受窗口)
  2. 接受窗口：接收端根据自己的资源情况动态调整并在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。只有当发送方发送并收到确认之后，才能将发送窗口右移。
  3. NOTE：接受窗口=0时发送方暂停发送数据并启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。

### 流量控制与拥塞控制

+ 流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。
+ 慢开始和快恢复的快慢指的是cwnd的设定值，而不是cwnd的增长速率。慢开始cwnd设定为1，而快恢复cwnd设定为ssthresh。
+ TCP Reno和Tahoe(废弃)：前者在快重传后执行满开始，后者则是执行快恢复

### 四次挥手(正常断开连接)

#### 过程

1. Client ===> Server:FIN、seq1=客户端最后发送序列号+1。(未响应则重发)
2. Server ===> Client:ACK、ack=seq1+1，seq2=服务器端最后发送序列号+1。此后处于**半关闭**状态(只能Server向Client单向发送数据)。
3. Server ===> Client:FIN、ACK、ack=seq1+1，seq2=w。(未响应则重发)
4. Client ===> Server:ACK、seq1=seq1、ack=w+1。等待2MSL后关闭

+ ![状态转移图](img/network/tcp-close.png)

#### 原因/优点

1. 四次挥手:Server端可能还有数据没有发送完毕，传送完毕后才会进入第三次挥手
2. 客户端不立即关闭:确保最后一个确认报文能够到达;让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

### 断开连接(客户端故障：保活计时器+探测报文)

服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

## UDP/User Datagram Protocol

+ 概述：无连接、支持一对一、一对多、多对一和多对多的通信、面向报文(对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部)
+ UDP一次发送一个报文,因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会使IP太小。
+ UDP**提供尽最大努力的交付**，不保证可靠交付。所有维护传输可靠性的工作需要用户在**应用层**来完成。没有TCP的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息。
+ UDP提供简单的差错检验。如果UDP校验和校验出UDP数据报是错误的，可以丢弃，也可以交付上层，但是要附上错误报告，告诉上层这是错误的数据报。

# 网络层

## ARP/RARP协议

## IP

+ |  类别   | 前缀(CIDR) | 网络位数 |                NOTE                |       私有地址        |       保留地址        |
    | :-----: | ---------- | :------: | :--------------------------------: | :-------------------: | :-------------------: |
    |    A    | 0(/8)      |    8     |                                    |       10.x.x.x        |    127.x.x.x(环回)    |
    |    B    | 10(/16)    |    16    | 100.64.x.x- 100.127.x.x(运营商NAT) | 172.16.x.x-172.31.x.x | 169.254.x.x(DHCP失败) |
    |    C    | 110(/24)   |    24    |                                    |      192.168.x.x      |                       |
    | D(群播) | 1110(/4)   |  未定义  |                                    |                       |                       |
    | E(保留) | 1111(/4)   |  未定义  |                                    |                       |                       |

### IP数据报

+ 首部数据长度是首部字段的二进制数的**4倍**B。
+ 总长度：首部长度 + 数据部分长度；
+ 首部检验和：数据报每经过一个路由器，都要重新计算检验和；
+ 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。
+ 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。
+ 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。

### 划分子网

+ 背景：ABC类别的网络号的基本控制粒度太大，对于一些小子网会造成大量的浪费。划分子网在有类网络的基础上，通过对IP地址的主机号进行再划分，把一部分划入网络号来划分各种类型大小的网络。
+ 表示：从主机号借用若干个比特作为子网号，掩码由网络号掩码和子网号掩码组成。
+ 支撑技术：VLSM（等长/变长子网划分，新标准中所有子网号都可用）、CIDR（子网聚合，用于路由汇总提高路由查找效率）
+ 路由过程：数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网

### 广播(仅用于UDP)

+ 实现：借助路由器的转发功能实现，任何情况下路由器都拒绝广播到255.255.255.255

### 多播/组播(仅用于UDP)

## NAT

+ 使用端口号的 NAT 也叫做网络地址与端口转换 NAPT，它使得多个专用网内部的主机共用一个全球 IP 地址。

## ICMP/IGMP

### ICMP

+ **封装在IP数据报中**，但是不属于高层协议。
+ 分为差错报告报文和询问报文。ping(ICMP Echo请求报文)，Traceroute(ICMP终点不可达差错报告报文:向目的主机发送TTL从1递增的ICMP报文，利用TTL的生命期控制间接使报文到达的最后一个节点返回差错报文，此探测路径不一定是真实路径)；

### IGMP

## VPN 虚拟专用网

+ 用公用的互联网作为本机构各专用网(几个保留地址段中的网络)之间的通信载体。
+ 基于隧道技术：要求多个网段有一个可以连接到互联网的路由器，该路由器A负责将数据进行加密发送到另一个路由器B，B解密并将数据交付到网络内部。

## ARP/RARP

+ 作用：**ARP协议完成了IP地址与物理地址的映射，RARP完成物理地址到IP地址的映射**。
+ 机制：每个主机会保存自己所在局域网中IP和MAC地址的映射表缓存，需要时先搜索自身后查询。
+ ARP过程：查询自身失败后，主机广播ARP请求信息(包含自身IP-MAC映射，查询的IP地址)，局域网主机接收消息并比较是否是自己，如果是则保存消息中的IP-MAC映射并响应广播，主机接到响应后先添加响应的映射后传送数据。如果局域网内查询失败则将ARP查询信息传送到本局域网的路由器上，交给路由器处理(路由器有目标网段的路由表，开启ARP代理，到其他网段的消息都会交给路由器代理转发)。

## 路由协议 ??????????????????不完整？？？？？？？？？？？？？

互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。

### 内部网关协议

#### RIP (应用层协议)

+ 基于距离向量的路由选择协议。
+ 原理：RIP协议让路由器按固定时间间隔后和相邻路由器交换路由表，经过若干次交换后，所有路由器都会知道自治系统中任何一个网络的最短距离和下一跳路由器地址
+ 总结：实现简单，开销小；最大距离(跳数)为15限制了网络规模，网络出现故障时要经过较长的时间才能将此信息传递到所有路由器。

```
* 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；
* 对修改后的 RIP 报文中的每一个项目，进行以下步骤：
* 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；
* 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。
* 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。
```

#### OSPF 开放最短路径优先

采用**洪泛法**向自治系统中**和所有路由器发送链路状态信息**，之后各自根据最短路径算法算出路由，放在OSPF路由表，OSPF路由与其他路由比较后优的加入全局路由表。

### 外部网关协议

#### BGP

用于AS自治系统间的动态路由协议，用于**AS间交换路由信息**。每个AS都要有一个BGP发言人，代表AS与其他AS交换信息。

# 数据链路层

## 基本问题

### 封装成帧

将网络层传输给下层的分组添加头部和尾部，用于标记帧的开始和结束

### 透明传输

**转义字符**：帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。

### 差错检测

循环冗余检验（CRC）来检查比特差错。

## 广播信道下的信道利用

### 信道复用

#### 频分复用

#### 时分复用

#### 统计时分复用

是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。

#### 波分复用

# 物理层

# 套接字

+ 套接字Socket是连接应用程序和网络驱动程序的桥梁，套接字Socket在应用程序中创建，通过绑定与网络驱动建立关系。此后，应用程序送给套接字Socket的数据，由套接字Socket交给网络驱动程序向网络上发送出去。计算机从网络上收到与该套接字Socket绑定IP地址和端口号相关的数据后，由网络驱动程序交给Socket，应用程序便可从该Socket中提取接收到的数据。

## socket文件与Linux设计哲学

+ Linux设计的一条基础哲学即一切皆文件，但是socket文件的实现与该原则有所违背，它的操作接口和标准文件接口非常不同

1. 创建socket必须用socket调用而不是open，socket在打开之前不能存在。
2. bind，connect，accept等都是独立的系统调用，没有标准文件操作与之对应。

+ 由于socket、管道等设计Linux的设计哲学由**一切皆文件退化为一切皆文件描述符**。

1. 一切皆文件： 文件属于Unix/Linux目录树，编址于统一命名空间。
2. 一切皆文件描述符： 文件描述符属于进程打开文件表，进程内可见。

## 套接字类型

### 本地套接字 Unix Socket

+ 本地套接字一般用于本机的IPC（进程间通行），其名字是Linux文件系统中的文件名（可以找到最终的实体文件），一般放在/tmp或/usr/tmp目录。

### 网络套接字 BSD Socket

+ 网络套接字的名字是与客户连接的特定网络有关的服务标识符（端口号或访问点）。这个标识符允许Linux将进入的针对特定端口号的连接转到正确的服务器进程，在文件系统中只有其描述符和描述符的已断开的文件链接。

## 套接字实现

+ linux以属于**sockfs文件系统**的特殊文件实现套接口，创建一个套接口就是在sockfs中创建一个特殊文件并建立起为实现套接口功能的相关数据结构。

### sockfs文件系统

+ linux的所有文件操作通过VFS实现了统一抽象，sockfs实现了VFS中的4种主要对象（超级块super block、索引节点inode、目录项对象dentry和文件对象file）。执行文件IO系统时VFS就将请求转发给sockfs，sockfs调用具体的协议实现IO。
+ socketfs作为伪文件系统被编译进内核(因为要支持整个TCP/IP协议栈)而非一个模块，它在系统启动到关闭期间总是被装载着的。

### [socket初始化](http://www.cppblog.com/qinqing1984/archive/2015/05/03/210521.html)

+ 内核引导时初始化网络子系统，进而调用sock_init（创建inode缓存，注册和挂载sockfs）

### [socket创建](http://www.cppblog.com/qinqing1984/archive/2015/05/03/210521.html)

+ 创建方法：`socket、accept、socketpair`三种系统调用。先构造inode，再构造对应的file，最后安装file到当前进程中（即关联映射到一个未用的文件描述符）。
![核心调用链](./img/network/socket_syscall_list.PNG)

### [socket操作](http://www.cppblog.com/qinqing1984/archive/2015/05/03/210522.html)

+ 既可以调用文件IO，也可以调用BSD Sockets API。基于文件方式的IO操作主要经过了VFS这一抽象层。

1. 以read为例的文件IO调用图：![READ_IO](./img/network/socket_io_via_file.png)
2. 以recv为例的socket式IO调用： ![RECV_IO](./img/network/socket_io_via_socket.png)

### [socket销毁](http://www.cppblog.com/qinqing1984/archive/2015/05/03/210522.html)

+ close是用户空间销毁socket的**唯一方法**，![./img/network/sockfs_close_calltree.PNG]

# 重要系统调用

+ 网络中进程标识：三元组<IP、Protocal、Port>

## socket()

+ `int socket(int domain, int type, int protocol)`
+ socket返回的socket描述字存在于协议族（AF_XXX）空间中，但没有一个具体的地址。

1. 协议族 domain：决定了socket的地址类，其中`AF_UNIX`(使用Unix Socket)决定了要用一个绝对路径名作为地址。
2. socket类型 type

| 流套接字（SOCK_STREAM） | 数据报套接字（SOCK_DGRAM） |                原始套接字（SOCK_RAW）                |
| :---------------------: | :------------------------: | :--------------------------------------------------: |
|           TCP           |            UDP             | 允许读写内核没有处理的IP数据包实现低层协议的直接访问 |

3. 协议 protocol：传输协议(`IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC`等)

+ **NOTE**：type与protocal参数不能随意组合，其取值不是两部分的笛卡尔积。

## bind()

+ `int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)`
+ 作用：将描述符sockfd绑定一个名字/本地协议地址，

1. addr：指向要绑定给sockfd的协议地址，其地址结构根据地址创建socket时的地址协议族的不同而不同。

## listen()

+ `int listen(int sockfd, int backlog)`
+ 服务端开启监听，此时的socket变为被动类型等待客户的连接请求

1. sockfd：要监听的socket描述字
2. backlog：可以排队的最大连接个数

## connect()

+ `int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen)`
+ 客户端向addr标识的断点发出请求（主动类型）

1. 参数和bind函数相同

## accept()

+ `int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)`
+ 取接收请求，此后完成连接的建立，可以类同于普通文件的操作进行网络I/O；

1. sockfd：服务端的socket描述符，即监听套接字
2. addr：用于返回客户端的协议地址，由**内容由内核自动创建**

+ 一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。

## close()

+ `int close(int fd)`
+ 该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用。
+ **NOTE**：close操作只是使相应socket描述字的**引用计数-1**，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。

# IO模型

+ 当一个用户态的函数试图进行IO时，由于用户态不能直接操纵IO，所以当一个read()函数发起读请求时，实际上发生了两件事。一是read()请求系统调用sys_read()，内核等待IO的数据就绪(获取并将数据拷贝到内核缓冲区)，另一个阶段是内核在数据就绪后将数据由内核态的空间拷贝到用户态空间供用户操纵数据。

## 阻塞式IO

![BIO](./img/network/block-io.jpeg)

+ Linux的**Socket在默认情况下都是阻塞的**，它会阻塞等待内核准备数据、阻塞等待内核数据拷贝到用户空间。

## 非阻塞是IO

![NBIO](./img/network/NBIO.png)

+ Linux下通过`fcntl(int fd,
  ...)`将默认阻塞的Socket变为非阻塞模式，此时进程在调用IO时会立即获得返回值：如果IO就绪就成功返回，否则返回`EWOULDBLOCK`错误。在函数返回错误后线程需要不断的**轮询**检查IO是否就绪(反复循环检查会推高CPU的占用率)。

## IO多路复用/事件驱动

![MIO](./img/network/MIO.png)

+ 用户在单个线程里同时监听多个套接字，通过 select 或 poll 轮询所负责的所有socket，当某个socket的数据就绪后就通知用户进程。此时系统调用第一次阻塞在select等函数上，第二次阻塞在由内核向用户拷贝数据上。

### Posix:select

+ 此时进程**被select函数阻塞**，select所管理的socket此时时非阻塞的。linux提供了四个宏来设置需要监听的文件描述符集合，所要监听的文件描述符集合fd_set类似于一个位图，select中间的三个文件描述符集合参数既是输入也是输出，程序用宏检测文件描述符集合中发生响应事件的文件描述符。
+ select监测的文件描述符范围为[0,nfds)
+ 在编程中需要将select置于循环结构中来循环处理新的链接

![select](./img/network/select-call.png)
![select](./img/network/select_call.png)
```cpp
FD_ZERO(int fd, fd_set *fds);
FD_SET(int fd, fd_set *fds);
FD_ISSET(int fd, fd_set *fds);
FD_CLR(int fd, fd_set *fds);
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *excptfds, struct timeval *timeout);
```

#### 优点

1. 可以使用单线程(占用资源少)实现对多个文件描述符集合的监测，同时服务多个文件描述符。
2. 跨平台支持

#### 缺点

1. select在确定是哪个文件描述符发生了相应的事件时需要对文件描述符集合进行轮询，当文件描述符集合比较大时这会消耗大量的资源。
2. select将事件的检测和事件的响应处理放在一个框架里处理，当响应比较复杂时会造成等待时间过长。
3. select监听的文件描述符上限为1024(linux/posix_types.h:#define \__FD\__SETSIZE 1024)
4. 每次调用select都需要将fdset在内核与用户态之间拷贝

### BSD:kqueue

### Linux:poll

* poll和select在本质上没有什么差别，都是轮询多个fd的状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。

```cpp
struct pollfd {
    int fd; /* 文件描述符 */
    short events; /*  事件掩码：等待的事件，由用户设置 */
    short revents; /* 操作结果事件掩码：实际发生了的事件，由内核在调用返回时设置 */
};
/*
events域:
　　POLLIN 　　　　　　　　有数据可读。
　　POLLRDNORM 　　　　  有普通数据可读。
　　POLLRDBAND　　　　　 有优先数据可读。
　　POLLPRI　　　　　　　　 有紧迫数据可读。
　　POLLOUT　　　　　　      写数据不会导致阻塞。
　　POLLWRNORM　　　　　  写普通数据不会导致阻塞。
　　POLLWRBAND　　　　　   写优先数据不会导致阻塞。
　　POLLMSGSIGPOLL 　　　　消息可用。
revents域：
   events域的所有可能值
　　POLLER　　   指定的文件描述符发生错误。
　　POLLHUP　　 指定的文件描述符挂起事件。
　　POLLNVAL　　指定的文件描述符非法。
*/
int poll (struct pollfd *fds, unsigned int nfds, int timeout);
/*
返回值与错误码：
  成功：
    超时前无事件发生：0
    有事件：发生的事件个数
  失败：
    返回-1，并设置errno
  　　EBADF　　       一个或多个结构体中指定的文件描述符无效。
  　　EFAULTfds　　 指针指向的地址超出进程的地址空间。
  　　EINTR　　　　  请求的事件之前产生一个信号，调用可以重新发起。
  　　EINVALnfds　　参数超出PLIMIT_NOFILE值。
  　　ENOMEM　　     可用内存不足，无法完成请求。
*/
```

#### 优点

1. 使用数组机制传递需要监听的文件描述符(第一个参数为数组首地址，第二个参数为数组长度)，突破了select文件描述符有限的缺点

#### 缺点

1. 任然需要使用轮询遍历的方式确定那个文件描述符发生了相应的事件
2. 在数据交互时文件描述符数组被整体复制于内核态和用户态之间，开销随监视的描述符增大而增大

### Linux:epoll（高效）

+ 通过监听、回调的机制避免了对文件描述符的遍历
+ 使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中
+ 底层涉及到的数据结构有红黑树和双向链表
![select](./img/network_call.png)

#### 工作模式

##### 边缘触发ET(高速)

+ 只支持非阻塞socket(避免一个文件描述符的阻塞造成其它多个文件描述符长期得不到响应)
+ 仅当状态发生变化时才会通知，即对于一个事件只通知一次，如果用户一直没有对该事件作出处理(从而导致它再次变为非就绪态)，内核不会发送更多的通知。

##### 电平触发LT(默认)

+ 同时支持阻塞和非阻塞两种方式
+ 只要发生的事件还没有被处理，内核就会一直向用户进程通知该事件

```cpp
struct epoll_event {
  __uint32_t events;  /* Epoll events */
  epoll_data_t data;  /* User data variable */
};
/*
events可以是以下几个宏的集合：
    EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
    EPOLLOUT：表示对应的文件描述符可以写；
    EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
    EPOLLERR：表示对应的文件描述符发生错误；
    EPOLLHUP：表示对应的文件描述符被挂断；
    EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
    EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里
*/
int epoll_create(int size);
//告诉内核监听的数目的大小，该参数只是给内核建立数据结构的一个建议值。其返回值时一个文件描述符，所以在使用完epoll后需要调用close()关闭。
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
// 事件注册函数
// op通过EPOLL_CTL_ADD，EPOLL_CTL_DEL，EPOLL_CTL_MOD三个宏表示对fd对应的监听事件的增删改
// event为具体要检测的事件
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
// 等待epfd上的IO事件，这些事件保存在长为maxevents的events事件数组里
```

#### 优点

+ 可以监听的文件描述符数量上限为最大可打开文件数目（`cat /proc/sys/fs/file-max`）
+ 使用队列而非轮询的方式来处理就绪的IO，队列里保留了就绪的IO，IO的效率不会随着监视fd的数量的增长而下降

## 信号驱动IO(不常用)

![SIO](./img/network/SIO.png)

+ 利用Linux的信号机制，用sigaction函数将SIGIO读写信号以及handler回调函数存在内核队列中。当设备IO缓冲区可写或可读时触发SIGIO中断，返回设备fd并回调handler。
+ 此方式下handler是在中断环境下运行，多线程不稳定而且要考虑信号的平台兼容性。再者SIGIO信号被POSIX定义为standard signals不会进入队列，所以同时存在多个SIGIO会只触发第一个SIGIO。

## 异步IO

![ASIO](./img/network/ASIO.jpeg)

+ 用户进程在发起异步IO的系统调用后会立即返回，当内核等待的数据就绪并由内核将数据拷贝到用户空间后，内核会向调用者发送信号通知IO操作已完成。由于进程以**信号**这种特殊的方式得知IO事件已经就绪，进程对这一信号的处理一般都不是立即处理。

### Windows:IOCP

| IO方式              | 数据准备 | 数据拷贝 | 优点 | 缺点 |
| ------------------- | -------- | -------- | ---- | ---- |
| 同步阻塞            | 阻塞     | 阻塞     |      |      |
| 同步非阻塞          | 非阻塞   | 阻塞     |      |      |
| 事件驱动/IO多路复用 | 非阻塞   | 阻塞     |      |      |
| 信号驱动            | 非阻塞   | 阻塞     |      |      |
| 异步IO              | 非阻塞   | 非阻塞   |      |      |

| IO函数 |    平台     | 设计模式 | 数据结构 |   上限   |    fd拷贝     | 事件追踪 |
| :----: | :---------: | :------: | :------: | :------: | :-----------: | :------: |
| select | posix/Linux | Reactor  |  bitmap  |   1024   |     每次      | 轮询O(n) |
|  poll  |    Linux    | Reactor  |   数组   | 系统限制 |     每次      | 轮询O(n) |
| epoll  |    Linux    | Reactor  |  红黑树  | 系统限制 | 首次epoll_ctl |   O(1)   |
| kqueue |     BSD     | Reactor  |          |          |               |          |
|  IOCP  |   Windows   | Proactor |          |          |               |          |

# IO模式

## Reactor

### 步骤

1. 应用向reactor注册多个监听设备以及回调函数
2. IO ready事件触发
3. reactor分发事件执行对应的回调函数
4. 应用在回调函数中进行IO操作。

## Proactor

### 步骤

* 与Reactor模式类似，区别在于proactor在IO ready事件触发后，完成IO操作再通知应用回调。
