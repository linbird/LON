# 其它

## URI与URL

* URI:Identifier，标识符
* URL:Location，定位符

## MSS/Maximum Segment Size

* 最大消息长度：TCP连接中发送的数据包的单位，理想情况下不会被IP层分片。其长度由双方协商(TCP首部的MSS选项)

## MTU/Maximum Transport Unit

* 最大传输单元：

# 概览

## OSI七层模型

* 应用层，会话层，表示层，传输层，网络层，数据链路层，物理层

## TCP/IP四层模型

* 应用层，运输层，网际层，网络接口层

## 实际五层结构

# 应用层

## SSH

## DHCP

## HTTP

* 概览:无状态，无连接(每次请求需要建立TCP连接)，明文(无身份确认、无完整性保护)，基于请求和响应，支持任意类型

### 重要演化

* HTTP/1.0:增加PUT、DELETE等方法
* HTTP/1.1:长连接/持久链接，管道
* HTTP/2.0:多路复用，服务器推送

1. 多路复用：通过单一的HTTP/2连接请求发起多重的请求-响应消息，多个请求stream共享一个TCP连接，实现多留并行而不是依赖建立多个TCP连接。

* HTTP/3.0:

### 方法

1. GET/查：查询，参数可以放入URL中(长度受浏览器限制)。该方法在再次访问网站中未改变的页面时可以使客户端使用缓存而节省流量(通过请求时的If-Modified-Since选项和响应时的状态码304 Not Modified实现)。
2. POST/增：提交，数据放在报文内部
3. PUT/改：
4. DELETE/删：

### 状态码

1. 1XX：信息类
2. 2XX：成功类
3. 3XX：重定向

* 301：永久转移
* 302：临时跳转

4. 4XX：客户端错误

* 400：请求错误
* 401：未经授权
* 404：资源不存在

5. 5XX：服务端错误

* 500：服务器内部发生不可预期错误
* 503：服务器当前不能处理请求

### 补丁

#### 应对无状态:Cookie;Session;HTTP/1.1持久连接

1. Cookie(用户通行证): 服务端生成Cookie传输并保存在客户端上，安全性差，如登录认证场景。
2. Session(用户唯一标识):服务端生成Session对象保存在服务端，用SeesionID标识此对象，此SessionID会随Cookie传输到客户端。安全性高，如保存用户购物车。**Session的实现依赖于Cookie**
3. 持久连接

* 客户端和服务端在各自的头中加入Connection: Keep-Alive，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。可以自定义连接重用的次数和保持时间。
* 长连接并不能强制保证连接是活跃的，他能保证当连接被关闭时可以得到一个通知。
* 结束传输：Content-Length指示大小；对于使用分块/chunked传输的动态生成文件则根据chunked编码判断（最后为一个空的chunked）。

4. URL重写：在URL结尾添加一个附加数据以标识该会话
5. 隐藏表单域：将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示

#### 分块传输

* 消息体由数量未定的块组成，并以最后一个大小为0的块为结束。
* 使用方法：HTTP消息头的Transfer-Encoding字段(标示报头将以何种方式进行传输)的值为chunked
* chunked 的优势在于服务器端可以边生成内容边发送，无需事先生成全部的内容。HTTP/2 不支持 Transfer-Encoding: chunked，因为 HTTP/2 有自己的 streaming 传输方式

#### 管道传输

1. 背景：默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。
2. 作用：通过借助持久连接的机制实现请求的批量提交而不必等待响应后在提交。
3. Note：

* 只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制。
* 管线化不会影响响应到来的顺序。
* HTTP/1.1标准仅仅要求服务器在处理管道传输的响应时不出错，不强制要求响应也要管线化，因此不一定能提升性能，所以Chrome和Firefox默认不提供管线化支持。

### 其他

#### Token抵御CSRF(跨站请求伪造)攻击

* 原理：斩断攻击者推测合法请求的途径
* 实现：

1. 参数加密编码
2. 添加随机参数Token(随机性、一次性、注意保密)

## HTTPS(HTTP over TLS)

* 概览：HTTP+SSL/TLS,主要目的是提供对**服务器**的身份认证，同时保护交换数据的隐私与完整性。

### 实现

#### 混合加密

* 过程：客户端和服务端首先协商好双方加密的方法，服务端发给客户端自己的数字证书(机构颁发或者自己制作)，客户端验证证书的效力(自己制作的需客户端手动验证)。验证证书后科客户端根据前面的协商过程生成会话密钥，随后使用服务端的公钥加密(非对称加密)会话密钥传输给服务端，服务端以私钥解密出会话密钥。随后双方以协商好的会话密钥传输数据(对称加密)。
* 原因：非对称加密资源需求高，服务器无法支持大量的连接

#### 数字摘要

* 通过单向哈希函数对原文(明文)生成固定长度的摘要，？？？？可以比较解密出来的原文的哈希结果和摘要是否一致来防止篡改？？？？

#### 数字签名

### 数字证书

* 内容:服务器的公钥、权威机构的信息、服务器域名。

#### 验证过程

1. 客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。
2. 然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。

### 缺点

1. HTTPS协议多次握手，延长了页面加载时间
2. SSL证书要钱，SSL的算法耗费资源

## DNS

## QUIC

# 传输层

## SSL->TLS

* 基础：非对称加密

### 过程

* 分别确定密钥交互算法、对称加密算法、消息认证算法

1. C->S:ClientHello、TLS版本、支持的加密和压缩算法、ClientRandom字符串
2. S->C:ServerHello、TLS版本、Server选择的算法，自己的证书(含公钥)、ServerRandom字符串。
3. C:根据自己信任的CA列表验证证书，可信则使用Server的公钥加密一段自己生成的随机数"premaster secret (预主密钥)"。
4. C->S:传输公钥加密后的随机数"premaster secret (预主密钥)"
5. S:使用私钥解密随机数，使用ClientRandom、ServerRandom和premaster secret通过之前协商的算法生成自己的共享对称主密钥KEY。
6. C->S:将Finish消息使用KEY加密后传输到服务端
7. S->C:
8. 完成，此后使用对称秘钥交互

### 证书信任链

* 即一个证书要依靠上一级证书来证明自己是可信的，最顶层的证书被称为根证书，拥有根证书的机构被称为根CA。
* 验证时需要保证证书的正确性以及证书和域名的对应。
* 证书信任链最终依赖根CA，根证书一般是操作系统自带（Firefox 浏览器通常是使用自带的一套证书信任机制，不受系统证书的影响）。

### 数字证书与服务器一一对应

* TLS握手阶段客户端发送的信息之中不包括服务器的域名，当一个服务器有多个网站时会分不清应该向客户端提供哪一个网站的数字证书。
* 改进:2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。

## TCP

* 概述：面向连接、面向字节流(把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块)、全双工、一对一的可靠传输协议

### 三次握手(建立连接)

* 目的：连接服务器指定端口，建立 TCP 连接并同步连接双方的序列号和确认号，交换TCP窗口大小信息，让双方都确认对方和自己的接收和发送功能是正常的。

#### 过程

1. Client ===> Server:SYN、ack=随机序列号seq1。进入SYN_SENT状态
2. Server ===> Client:ACK、seq=seq1+1、SYN、ack=随机序列号seq2，进入SYN_RCVD状态。未收到响应就重发5次ACK+SYN后进入CLOSED状态。
3. Client ===> Server:ACK、seq=seq2+1。检查seq1的回应后回应进入ESTABLISHED状态，服务端动作相同。

* ![状态转移图](img/network/tcp-establish.png)

#### 原因/优点

1. 两次：可能会出现已失效的连接请求报文段(在网络中滞留时间过长)又传到了服务器端致使服务器建立无用连接，其次，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。
2. 四次：可以但没必要(四次：第二次拆解为两次)

#### 其他问题

1. 随机序列号:避免同一个套接字上建立的多次连接传送的数据混淆(网络中某个包的整体传输时间过长时)。

### 可靠传输

* 依赖校验和，确认和重传机制

#### 超时重传
* 若一个已经发送的报文段在超时时间内($RTO_i = RTTs_i+4*RTTd_i = (1-a)RTTs_{i-1} + aRTT + 4RTTd_i$)没有收到确认，就重传这个报文段。TCP在超时重传失败后其超时时间的确定采用二进制指数退避算法。

#### 自动重传(ARQ,auto repeat request)
* 主要应用在无线链路层
1. 停等式（stop-and-wait）:发完一个就停止，确认后再发下一个
2. 回退n帧（go-back-n）:维持一个发送窗口,不用确认就能发，对last one确认，失败需要回退N
3. 选择性重传（selective repeat）:当发送方接收到接收方的状态报告指示报文出错，发送方只发送传送发生错误的报文。

### 滑动窗口机制

* 滑动窗口存在于发送端和接收端，窗口内为当前可以被发送或接受的所有消息。

1. 发送方窗口：在滑动窗口内的数据才能被传送，窗口的两边分别是已发送但未确认或者未发送(只会出现在一侧)的数据，重传时可以直接从滑动窗口中取数据。
2. 接收方窗口：作为接收方对数据存储的一个缓冲区，它只对最后一个按序到达的字节进行确认，确认后滑动窗口移动以接受新的数据。

### 拥塞控制

* 目的与方法：防止过多数据注入网络(传输失败会重传，导致拥塞加重)，导致网络过载。
* ![拥塞控制概览](img/network/tcp-flow-control.png)

#### 慢开始

cwnd以1为初始值，在未到ssthresh(>=2)之前每次成功传输后，cwnd增长为原来的两倍，传输失败就令ssthresh=cwnd/2。

#### 拥塞避免(加性增、乘性减)

当cwnd>ssthresh时，进入拥塞避免，每个成功传输轮次后swnd=cwnd+1，当出现超时令ssthresh = cwnd/2，cwnd从1开始重复满开始和拥塞避免的过程。

#### 快重传

接收方只对最后一个收到的**有序报文段**进行确认，接收方在收到一个失序的报文段后就立即发出重复确认**而不要等到自己发送数据时捎带确认**(可以使发送方及早知道有报文段没有到达对方)，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而**不必等待设置的重传计时器**时间到期。

#### 快恢复

当发送方连续收到三个重复确认时，令ssthresh=cwnd/2，cwnd=ssthresh <+3*MSS>，**直接进入拥塞避免**(在这种情况下，只是丢失个别报文段，而不是网络拥塞)。

#### TCP拥塞控制扩展

1. 基于丢包的拥塞控制：Tahoe、Reno、New Reno
2. 基于时延RTT的带宽预测：vegas
3. 基于丢包和RTT：westwood
4. 二分搜索最佳cwnd：BIC-TCP
5. 连续拥塞间隔：CUBIC
6. 基于精准带宽计算：BBR

* BBR摒弃了丢包和实时RTT作为拥塞控制因素。引入BDP管道容量来衡量链路传输水平。BBR追求的是在链路最小RTT（物理链路延迟）的状态下，找到最大带宽。

### 流量控制

* 目的与方法：通过改变滑动窗口大小控制发送方发送速率
* 滑动窗口
  1. 滑动窗口<=min(拥塞窗口、接受窗口)
  2. 接受窗口：接收端根据自己的资源情况动态调整并在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。只有当发送方发送并收到确认之后，才能将发送窗口右移。
  3. NOTE：接受窗口=0时发送方暂停发送数据并启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。

### 流量控制与拥塞控制

* 流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。
* 慢开始和快恢复的快慢指的是cwnd的设定值，而不是cwnd的增长速率。慢开始cwnd设定为1，而快恢复cwnd设定为ssthresh。
* TCP Reno和Tahoe(废弃)：前者在快重传后执行满开始，后者则是执行快恢复

### 四次挥手(正常断开连接)

#### 过程

1. Client ===> Server:FIN、seq1=客户端最后发送序列号+1。(未响应则重发)
2. Server ===> Client:ACK、ack=seq1+1，seq2=服务器端最后发送序列号+1。此后处于**半关闭**状态(只能Server向Client单向发送数据)。
3. Server ===> Client:FIN、ACK、ack=seq1+1，seq2=w。(未响应则重发)
4. Client ===> Server:ACK、seq1=seq1、ack=w+1。等待2MSL后关闭

* ![状态转移图](img/network/tcp-close.png)

#### 原因/优点

1. 四次挥手:Server端可能还有数据没有发送完毕，传送完毕后才会进入第三次挥手
2. 客户端不立即关闭:确保最后一个确认报文能够到达;让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

### 断开连接(客户端故障：保活计时器+探测报文)

服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

## UDP/User Datagram Protocol

* 概述：无连接、支持一对一、一对多、多对一和多对多的通信、面向报文(对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部)
* UDP一次发送一个报文,因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会使IP太小。
* UDP**提供尽最大努力的交付**，不保证可靠交付。所有维护传输可靠性的工作需要用户在**应用层**来完成。没有TCP的确认机制、重传机制。如果因为网络原因没有传送到对端，UDP也不会给应用层返回错误信息。
* UDP提供简单的差错检验。如果UDP校验和校验出UDP数据报是错误的，可以丢弃，也可以交付上层，但是要附上错误报告，告诉上层这是错误的数据报。

# 网络层

## ARP/RARP协议

## IP

* |  类别   | 前缀(CIDR) | 网络位数 |                NOTE                |       私有地址        |       保留地址        |
    | :-----: | ---------- | :------: | :--------------------------------: | :-------------------: | :-------------------: |
    |    A    | 0(/8)      |    8     |                                    |       10.x.x.x        |    127.x.x.x(环回)    |
    |    B    | 10(/16)    |    16    | 100.64.x.x- 100.127.x.x(运营商NAT) | 172.16.x.x-172.31.x.x | 169.254.x.x(DHCP失败) |
    |    C    | 110(/24)   |    24    |                                    |      192.168.x.x      |                       |
    | D(群播) | 1110(/4)   |  未定义  |                                    |                       |                       |
    | E(保留) | 1111(/4)   |  未定义  |                                    |                       |                       |

### 划分子网

* 背景：ABC类别的网络号的基本控制粒度太大，对于一些小子网会造成大量的浪费。划分子网在有类网络的基础上，通过对IP地址的主机号进行再划分，把一部分划入网络号来划分各种类型大小的网络。
* 表示：从主机号借用若干个比特作为子网号，掩码由网络号掩码和子网号掩码组成。
* 支撑技术：VLSM（等长/变长子网划分，新标准中所有子网号都可用）、CIDR（子网聚合，用于路由汇总提高路由查找效率）
* 路由过程：数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网

### 广播(仅用于UDP)

* 实现：借助路由器的转发功能实现，任何情况下路由器都拒绝广播到255.255.255.255

### 多播/组播(仅用于UDP)

## ARP/RARP

* 作用：**ARP协议完成了IP地址与物理地址的映射，RARP完成物理地址到IP地址的映射**。
* 机制：每个主机会保存自己所在局域网中IP和MAC地址的映射表缓存，需要时先搜索自身后查询。
* ARP过程：查询自身失败后，主机广播ARP请求信息(包含自身IP-MAC映射，查询的IP地址)，局域网主机接收消息并比较是否是自己，如果是则保存消息中的IP-MAC映射并响应广播，主机接到响应后先添加响应的映射后传送数据。如果局域网内查询失败则将ARP查询信息传送到本局域网的路由器上，交给路由器处理(路由器有目标网段的路由表，开启ARP代理，到其他网段的消息都会交给路由器代理转发)。

## 路由协议

### BGP

# 数据链路层

# 物理层
