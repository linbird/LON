# 其它

## URI与URL

* URI:Identifier，标识符
* URL:Location，定位符

## MSS/Maximum Segment Size

* 最大消息长度：TCP连接中发送的数据包的单位，理想情况下不会被IP层分片。其长度由双方协商(TCP首部的MSS选项)

## MTU/Maximum Transport Unit

* 最大传输单元：

# 概览

## OSI七层模型

* 应用层，会话层，表示层，传输层，网络层，数据链路层，物理层

## TCP/IP四层模型

* 应用层，运输层，网际层，网络接口层

## 实际五层结构

# 应用层

## SSH

## DHCP

## HTTP

* 概览:无状态，无连接(每次请求需要建立TCP连接)，明文(无身份确认、无完整性保护)，基于请求和响应，支持任意类型

### 重要演化

* HTTP/1.0:增加PUT、DELETE等方法
* HTTP/1.1:长连接/持久链接，管道
* HTTP/2.0:多路复用，服务器推送

1. 多路复用：通过单一的HTTP/2连接请求发起多重的请求-响应消息，多个请求stream共享一个TCP连接，实现多留并行而不是依赖建立多个TCP连接。

* HTTP/3.0:

### 方法

1. GET/查：查询，参数可以放入URL中(长度受浏览器限制)。该方法在再次访问网站中未改变的页面时可以使客户端使用缓存而节省流量(通过请求时的If-Modified-Since选项和响应时的状态码304 Not Modified实现)。
2. POST/增：提交，数据放在报文内部
3. PUT/改：
4. DELETE/删：

### 状态码

1. 1XX：信息类
2. 2XX：成功类
3. 3XX：重定向

* 301：永久转移
* 302：临时跳转

4. 4XX：客户端错误

* 400：请求错误
* 401：未经授权
* 404：资源不存在

5. 5XX：服务端错误

* 500：服务器内部发生不可预期错误
* 503：服务器当前不能处理请求

### 补丁

#### 应对无状态:Cookie;Session;HTTP/1.1持久连接

1. Cookie(用户通行证): 服务端生成Cookie传输并保存在客户端上，安全性差，如登录认证场景。
2. Session(用户唯一标识):服务端生成Session对象保存在服务端，用SeesionID标识此对象，此SessionID会随Cookie传输到客户端。安全性高，如保存用户购物车。**Session的实现依赖于Cookie**
3. 持久连接

* 客户端和服务端在各自的头中加入Connection: Keep-Alive，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。可以自定义连接重用的次数和保持时间。
* 长连接并不能强制保证连接是活跃的，他能保证当连接被关闭时可以得到一个通知。
* 结束传输：Content-Length指示大小；对于使用分块/chunked传输的动态生成文件则根据chunked编码判断（最后为一个空的chunked）。

4. URL重写：在URL结尾添加一个附加数据以标识该会话
5. 隐藏表单域：将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示

#### 分块传输

* 消息体由数量未定的块组成，并以最后一个大小为0的块为结束。
* 使用方法：HTTP消息头的Transfer-Encoding字段(标示报头将以何种方式进行传输)的值为chunked
* chunked 的优势在于服务器端可以边生成内容边发送，无需事先生成全部的内容。HTTP/2 不支持 Transfer-Encoding: chunked，因为 HTTP/2 有自己的 streaming 传输方式

#### 管道传输

1. 背景：默认情况下 HTTP 协议中每个传输层连接只能承载一个 HTTP 请求和响应，浏览器会在收到上一个请求的响应之后，再发送下一个请求。
2. 作用：通过借助持久连接的机制实现请求的批量提交而不必等待响应后在提交。
3. Note：

* 只有 GET 和 HEAD 请求可以进行管线化，而 POST 则有所限制。
* 管线化不会影响响应到来的顺序。
* HTTP/1.1标准仅仅要求服务器在处理管道传输的响应时不出错，不强制要求响应也要管线化，因此不一定能提升性能，所以Chrome和Firefox默认不提供管线化支持。

### 其他

#### Token抵御CSRF(跨站请求伪造)攻击

* 原理：斩断攻击者推测合法请求的途径
* 实现：

1. 参数加密编码
2. 添加随机参数Token(随机性、一次性、注意保密)

## HTTPS(HTTP over TLS)

* 概览：HTTP+SSL/TLS,主要目的是提供对**服务器**的身份认证，同时保护交换数据的隐私与完整性。

### 实现

#### 混合加密

* 过程：客户端和服务端首先协商好双方加密的方法，服务端发给客户端自己的数字证书(机构颁发或者自己制作)，客户端验证证书的效力(自己制作的需客户端手动验证)。验证证书后科客户端根据前面的协商过程生成会话密钥，随后使用服务端的公钥加密(非对称加密)会话密钥传输给服务端，服务端以私钥解密出会话密钥。随后双方以协商好的会话密钥传输数据(对称加密)。
* 原因：非对称加密资源需求高，服务器无法支持大量的连接

#### 数字摘要

* 通过单向哈希函数对原文(明文)生成固定长度的摘要，？？？？可以比较解密出来的原文的哈希结果和摘要是否一致来防止篡改？？？？

#### 数字签名

### 数字证书

* 内容:服务器的公钥、权威机构的信息、服务器域名。

#### 验证过程

1. 客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。
2. 然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。

### 缺点

1. HTTPS协议多次握手，延长了页面加载时间
2. SSL证书要钱，SSL的算法耗费资源

## DNS

# 传输层

## SSL->TLS

* 基础：非对称加密

### 过程

* 分别确定密钥交互算法、对称加密算法、消息认证算法

1. C->S:ClientHello、TLS版本、支持的加密和压缩算法、ClientRandom字符串
2. S->C:ServerHello、TLS版本、Server选择的算法，自己的证书(含公钥)、ServerRandom字符串。
3. C:根据自己信任的CA列表验证证书，可信则使用Server的公钥加密一段自己生成的随机数"premaster secret (预主密钥)"。
4. C->S:传输公钥加密后的随机数"premaster secret (预主密钥)"
5. S:使用私钥解密随机数，使用ClientRandom、ServerRandom和premaster secret通过之前协商的算法生成自己的共享对称主密钥KEY。
6. C->S:将Finish消息使用KEY加密后传输到服务端
7. S->C:
8. 完成，此后使用对称秘钥交互

### 证书信任链
* 即一个证书要依靠上一级证书来证明自己是可信的，最顶层的证书被称为根证书，拥有根证书的机构被称为根CA。
* 验证时需要保证证书的正确性以及证书和域名的对应。
* 证书信任链最终依赖根CA，根证书一般是操作系统自带（Firefox 浏览器通常是使用自带的一套证书信任机制，不受系统证书的影响）。

### 数字证书与服务器一一对应

* TLS握手阶段客户端发送的信息之中不包括服务器的域名，当一个服务器有多个网站时会分不清应该向客户端提供哪一个网站的数字证书。
* 改进:2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。

## TCP

* 概述：面向连接的可靠传输协议

### 三次握手(建立连接)
* 目的：连接服务器指定端口，建立 TCP 连接并同步连接双方的序列号和确认号，交换TCP窗口大小信息。
#### 过程

1. Client ===> Server:SYN
2. Server ===> Client:ACK(回应SYN)+SYN
3. Client ===> Server:ACK(回应SYN)

#### 原因/优点

#### 缺点

### 可靠传输
* 依赖校验和，确认和重传机制
#### 原型实现

* 发送端等待接受接收端的ACK响应以确定成功送达，超时未收到ACK则重传数据(但实际上超时未收到ACK不一定是因为未收到数据)。重发数据之后等待时间以2、4倍的指数时间延长，当重发次数超过阈值后则会认被认为网络故障而中止连接。
* 超时时间：根据RTT的变化调整，其值大于RTT与RTT抖动之和

### 数据的顺序和非重复
* 给数据分节进行排序，并使用累积确认


### 传输窗口控制

* 背景：当在传输时延较大的网络中对消息逐个确认时，通信性能太差。

### 拥塞控制
* 动态改变窗口的大小
### 流量控制
* 滑动窗口


### 四次挥手(断开连接)

#### 过程

1. Client ===> Server:FIN
2. Server ===> Client:ACK(回应FIN)
3. Server ===> Client:FIN
4. Client ===> Server:ACK(回应FIN)

#### 原因/优点

#### 缺点

## UDP/User Datagram Protocol

* 概述：无连接，接受上层数据只管立即注入到网络中

# 网络层

## ARP/RARP协议

## IP

# 数据链路层

# 物理层
