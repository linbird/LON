# 内存管理

## 标准库支持
* 标准库为operator new/new[]和operator delete/delete[]分别提供了抛出和不抛出异常的重载版本。用户可以在全局作用域或类作用域定义自己的重载并实现。
* note:new[]与delete[]需要成对使用，原因在于这一对函数是为对象数组服务的。new[]为了保存数组的大小信息，再申请内存时多申请了4B(32bit下)放在首部来存储长度信息，而delete也需要长度信息来确定调用析构函数的次数

## new(new operator)的具体实现过程(具体实现方法没有一定之规)

1. 调用operator new函数（new[]调用的时operator new[]函数）分配一块足够大的未命名的原始内存空间。
2. 编译器调用类的构造函数构造对象，传入初值。
3. 完成对象构造后返回对象指针。

## new 与 malloc 的区别

* new可以实现内存的初始化，在分配和释放内存时会掉用类自己的构造和析构函数。
* new在分配成功时返回的是对象类型的指针，而失败时会抛出异常(bad\_alloc或者构造函数的异常)。malloc返回void\*指针，失败时返回null。
* new所需的内存大小通过自动计算类型大小确定，malloc必须显式指定大小。
* new可以被重载，malloc不可以重载。
* malloc可以借助realloc来扩充内存（如果原指针指向的空间有足够的连续空间则原地扩大可分配的内存地址返回原指针，否则寻找满足长度的连续内存空间并将数据拷贝到新空间返回新空间首地址并释放原地址空间）。new没有对应的函数支持。
* new可以通过set\_new\_handler函数指定的无参无返回回调函数在不能分配而返回异常之前借助回调函数完成一些操作(可以先释放一些空间，然后再尝试申请空间)。

## 由于重载operator new/new[]的影响比较大，因此在需要改变内存管理策略的情况下，推荐使用replacement new或者实现一个新的new

* replacement new：在传入指针指向的内存空间(堆、栈甚至静态存储区)上构造对象。因此这一类的内存不能使用delete系列函数释放，因为这个内存不是new动态申请的，但是这一类对象必须显式调用类的析构函数。placement new在已经预先准备好的内存中分配内存，避免了查找可用内存空间和一些系统调用，非常适合那些对时间要求比较高，长时间运行不希望被打断的应用程序。

# 多态

多态指的是对同一接口调用会表现出不同行为的一种现象。可分为静态多态和动态多态：

## 动态多态：又称运行时多态、晚绑定[基类虚函数定义接口，继承类负责实现]。实现方法为虚函数

* 设计思想：在基类中把多个相关的对象共同的功能声明为多个公共的虚函数接口。各个子类重写这些虚函数以完成具体的功能。客户端的代码（操作函数）通过指向基类的引用或指针来操作这些对象，对虚函数的调用会自动绑定到实际提供的子类对象上去。
* 只有当程序运行时才能最终确定调用的具体的方法。其实施条件：

1. 含有虚函数的基类
2. 继承自虚基类的子类，子类和基类的成员函数签名完全相同(返回值、函数名、参数列表)
3. 将子类对象的指针或者引用赋值给基类类型的指针或引用并以此调用虚函数

* 优点：分离了接口与实现，方便了复用;便于处理同一继承体系下的异质对象
* 缺点：运行时绑定有开销;编译器无法优化虚函数;不方便修改接口

## 静态多态：又称编译器多态、早绑定[模板定义接口，类型参数定义实现]。实现的方法有函数重载以及模板

* 设计思想：对于相关的对象类型，直接实现它们各自的定义，不需要共有基类，甚至可以没有任何关系。只需要各个具体类的实现中要求相同的接口声明，这里的接口称之为隐式接口。客户端把操作这些对象的函数定义为模板，当需要操作什么类型的对象时，直接对模板指定该类型实参即可（或通过实参演绎获得）。
* 系统在编译期就可以确定程序将要执行哪个函数。
* 优点：早绑定效率高，编译器可以优化;可以通过特化处理特殊类型;方便了泛型编程
* 缺点：借助模板实现的多态代码膨胀、编译耗时、调试困难;不能处理异质对象

# 虚函数

## 实现机制：为了减少多个子类初始化时都需要初始化基类的开销，对于含有虚函数的基类，其对象的前四个字节会保存一个地址，该地址指向类的虚函数表

## 虚函数表内容

* 每个类有一个或多个虚函数表，对象只持有指向虚函数表的地址。而一个类的多个实例在调用同一地址的函数时之所以表现不同，是因为类的成员函数在编译时被自动在参数列表中加入了this指针参数，不同对象的this指针被传入函数。
* 虚函数表中的每一个表项记录了虚函数的地址，表的末尾项标记了表是否结束。
* 表项按照虚函数的申明顺序存放。

## 继承下的虚函数表

1. 单继承无重写：则表无覆盖，子类的虚函数表项接到父类的表项之后。
2. 单继承有重写：子类重写的虚函数地址会覆盖父类中被重写的虚函数的表项，其他子类虚函数表项接到后面。
3. 多继承无重写：子类含有多个虚函数表和多个(linux/g++)虚函数表指针。子类的虚函数表项被放在第一个申明的基类的虚函数表项的后边构成一张表，其余基类的虚函数表被依次放到后边，此时子类持有多个虚函数表。
4. 多继承有重写：子类重写的虚函数地址会覆盖所有基类中被重写的虚函数的表项，其余同第三条。
5. 有虚函数的虚继承：
6. 无虚函数的虚继承：

## 虚函数与纯虚函数

1. 虚函数：

* 思想：**希望**子类可以各自为自己父类提供的虚函数提供个性化的实现，当子类没有实现时可以使用父类的缺省实现。
* 由1可知虚函数必须提供实现

2. 纯虚函数：

* 思想：**强制**子类必须提供纯虚函数的个性化实现，否则子类还是一个纯虚基类。
* 申明在基类中的不需要实现的虚函数(这样的类被称为抽象类，不能实例化对象)，纯虚函数在派生类中定义以后，派生类才能实例化出对象。
* 如果不加显式约束的话，基类的纯虚函数在子类中自动变为了虚函数。

## 类中涉及到堆上内存分配的，应当将析构函数申明为虚函数

# 智能指针(smart\_ptr)

1. 设计目的：为了避免使用原声指针不当造成的内存泄漏(忘记释放)以及非法引用(被提前释放内存)的问题，设计智能指针概念来自动管理内存，其具有指针的行为(解引用等)。
2. 设计思想：RAII(Resource Acquisition is Initialization)使用类来管理(而非拥有)资源，将资源和对象的生命周期绑定，也就是说在构造函数中申请分配资源，在析构函数中释放资源。
3. 实现原则：智能指针对象作为普通变量被分配在栈空间，当智能指针对象离开作用域或者其引用失效时，智能指针对象自动调用其析构函数来管理对象所持有的资源。

## 几种智能指针(>=C++11)

1. auto\_ptr(已弃用)：C++98的方案，C++11已经抛弃。采用排它所有权模式，当出现语法中允许的拷贝构造和赋值时，资源所有权会由源对象转移到新对象中，此时再使用源对象时会空引用，为了解决问题设计了unique\_ptr。此外auto\_ptr在析构中使用的delete也不能管理动态开辟的数组。
2. unique\_ptr(scoped\_ptr)：**独占资源所有权**实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象(在语义上禁止了拷贝构造和赋值运算[库申明而不实现这两个函数，且被private保护]，但是允许用右值进行赋值)。boost：：scoped\_ptr是一个不允许转移所有权独占性智能指针。
3. shared\_ptr：**共享资源所有权**，多个对象共用一个引用计数(库实现了对计数的原子操作)记录内存单元被引用的次数。除了可以通过new、传入auto\_ptr、unique\_ptr、weak\_ptr来构造，调用release()时当前指针会计数减一，计数等于0时释放资源。无法解决循环引用问题。
4. weak\_ptr：**能访问资源，但不控制生命周期**。它指向一个shared\_ptr管理的对象，进行该对象的内存管理的是强引用的shared\_ptr，wake\_ptr作为shared\_ptr的观察者，其构造和析构不会改变強引用的计数。和shared\_ptr配合用来解决循环引用。但由于wake\_ptr没有重载operator \*和operator ->，因此不能使用其访问指向对象，需要使用lock方法从wake\_ptr得到shared\_ptr后才可以。
5. scoped\_arry：功能和scoped\_ptr相同，但是重载了operator[]函数，可以管理数组
6. shared\_arry：功能和shared\_ptr相同，但是重载了operator[]函数，可以管理数组

# 拷贝构造和赋值

* 两者和析构函数一起构成C++三大函数（The Big Three）

1. 申明时初始化、参数的值传递、以值返回时调用拷贝构造函数，当用户没有自定义拷贝构造函数时，编译器会提供一个默认的执行浅拷贝/位拷贝的拷贝构造函数(合成的拷贝构造函数)。
2. 赋值/赋值构造函数应用于两个已经构造的对象，为了提高赋值时的异常安全性，赋值操作应当遵守copy/move and swap的实现原则。

# friend

* 设计目的：提供给友元访问自己私有和保护成员的一种机制。
* 表现形式：友元类、友元函数。
* note：友元关系不具有继承性和传递性。

# explicit

1. 背景：在类的构造函数只传递一个有效参数(单参或者多参时后面都有默认参数)时，C++在编译时会默认将该构造函数参数类型的数据转换为该类对象。
2. 作用：explicit可以阻止构造函数的这种转换，避免一些难以发现的错误。

# const

* const修饰的变量的可见范围为文件作用域

# PIML(pointer to implementation)

1. 目的：通过使用指针的方式隐藏对象的实现细节，将文件间的编译依存关系降至最低的方法之一。
2. 实现原理：利用了前置申明。在C++语言中，要定义某个类型的变量或者使用类型的某个成员，就必须知道这个类的完整定义，其例外情况是：如果定义这个类型的指针，或者该类型是函数的参数或者返回类型(即使是传值类型的)，那么就可以通过前置声明引入这个类型的名字，而不需要提供暴露其完整的类型定义，从而类型的完整定义可以被隐藏在其他hpp头文件或者cpp实现文件中，而这个指针也被称为不透明指针(opaque pointer)。
3. 实现方法：在API的头文件中提供接口类的定义以及实现类的前置声明**接口类不能include实现类的头文件，否则白干**，实现类的本身定义和成员函数的实现都隐藏在cpp文件中去，同时为了避免实现类的符号污染外部名字空间，实现类大多作为接口类的内部嵌套类的形式。
4. 其他优点：信息隐蔽、加速编译、更好的二进制兼容性、惰性分配

# GDB调试

## 查看内存

* x/<\[查看单位数n\]\[显示格式f\]\[每单位字节数u\]> <待查看起始地址>

1. n：整数
2. f：x十六进制;d十进制;u十六进制显示无符号整型;o八进制;t二进制;a十六进制;c字符;f浮点数;
3. u： b 表示单字节， h 表示双字节， w 表示四字 节， g 表示八字节

# 3P

* Public，Protected，Private控制本类、子类、外部调用对类中成员的访问权限，访问控制逐渐严格(protect屏蔽外部访问，private只有本类可见)。
* 子类对父类的访问控制权限由父类控制，三种继承方式不影响子类对父类的访问权限。继承方式是为了控制子类的调用方对父类的访问，三种继承相当于将父类的public和protect成员访问权限变为继承方式所标明的权限。

# 重载、重写(覆盖)和隐藏

1. 重载：涉及的多方在**同一个作用域**中(同一类中或者都在全局作用域...)，且多方的函数名一定相同，函数参数列表一定不同，重载和被重载函数可以被virtual修饰也可以不被修饰。
2. 重写：涉及的多方在**多个类中**，多方的函数名、参数列表以及返回值类型必须完全相同，基类的函数必须由virtual修饰。
3. 隐藏：涉及的多方在**多个类中**，多方的函数名一定相同，参数列表不一定相同，也无论基类函数是否被virtual修饰。

* 被隐藏的函数无法通过子类调用到，即使实参数列表完全匹配被隐藏函数的形式参数列表。

# 右值引用

1. 意义：C++11提出的右值引用解决了C++的重大历史遗留问题，通过右值引用消除了标准库中的大量不必要的开销(容器等)同时为其他标准库提供了实现的可能。
2. 作用：右值引用本身只是一种概念，是为了实现move和forward而创造出的新的产物。成为右值引用对象意味着该对象所持有的资源的所有权可以安全的被转移给其他对象，从而避免了拷贝、析构等操作。

## 右值引用、移动语义与完美转发

* 右值被绑定到右值引用后，其生命周期将捆绑到右值引用上，此时可以修改右值引用所引用的值。
* 作为函数的参数，永远是一个左值，即使它(在函数的参数列表中)的类型是一个右值引用，因为函数调用时参数是需要被压栈的，这意味着参数一定有其地址。
* move和forward：

1. move和forward从语义上容易造成其一定执行了某种动作的错觉，其实move和forward是执行类型转换的函数模板，他们在运行时并不产生实际代码。
2. move本质上是一个无条件的将参数转换为右值的函数模板，或者说是static\_cast<T&&>()的简单封装。
3. forwaed本质上是一个满足一定条件时才将参数转换为右值的函数模板。forward的使用需要两个参数(模板类型参数和函数参数)，只有函数参数是被右值初始化时，它才会将参数转换为右值，同时保留着该参数的左值性或右值性。
4. move和forward的使用规范：对右值引用使用std：：move，对通用引用使用std：：forward。

* 万能引用/通用引用：形如T&&**且**包含类型推导的引用形式可以被称为通用引用(如auto&&以及某些模板类/函数的参数)，否则就是右值引用。万能引用的实际引用方式取决与其被初始化时所使用的对象的引用类型。

1. 由于万能引用既能够绑定右值引用也可以绑定左值引用，所以可以被设计作为函数的参数，可以避免为不同的参数类型分别定义实现不同的重载函数。
2. 当应用1时到函数重载时又会造成问题，由于通用引用的类型推导可以匹配到大量的类型[重载时精确匹配优先与类型提升转换]，由于这种贪婪性质，万能引用和重载结合会造成问题。

## 几种类型的绑定问题

1. 普通的左/右值引用只能绑定到普通的左/右值
2. const类型的左值引用可以绑定到普通的左/右值和const的左/右值
3. const类型的右值引用可以绑定到任意类型的右值

# 类型转换

## 传统类型转换

* 即C风格的类型转换可能带来一些隐患，让一些问题难以察觉.
* 在类模型中有时也会用到传统的类型转换方式，例如重载operator T函数实现类向类T的转换。

1. 隐式类型转换：由编译器自动完成，一般只作用到基本数据类型，将小内存的类型向大内存或相同内存大小的类型转换，但是其结果通常是不可预期的。
2. 显式/强制类型转换：显式要求编译器要转换的目标类型

## 标准类型转换

* 优点：使用新的转换函数可以清楚的理解转换的具体含义，且支持一定程度的安全检查

1. static\_cast<type-id>(expression)：用于有一定关系的指针/引用/对象以及基础数据之间。所谓关系在指针和引用上通常指继承关系[上转安全，下转危险]，在对象间通常按照先构造函数后类型转换运算符(operator TYPE)的顺序转换。
2. const\_cast<type-id>(expression)：用于去除指针/引用的const/volatile限定符，转换前后数据的最终指向并不会改变。但并不意味着可以对原对象修改(取决于源对象的限定符)。
3. reinterpret\_cast<type-id>(expression)：任意指针/引用类型之间、指针与大整数类型(与指针相同大小的比特位)、整数/枚举到指针之间的转换。该转换会产生一个和原值比特位一模一样的新值。
4. dynamic\_cast<type-id[expression](有RTTI支持)]：只接受基于类对象的指针和引用的类转换，且要求源和目标的类型具有继承关系。且该转换的实现依赖虚函数表。

## 建议

1. 只在数值类型（包括整型、浮点型、字符类型和枚举）上使用传统的转换方式(C式或函数式)。
2. 去const属性用const\_cast。
3. 基本类型转换用static\_cast。
4. 多态类之间的类型转换用daynamic\_cast。
5. 不同类型的指针类型转换用reinterpreter\_cast。

* 总结static\_cast和reinterpret\_cast运算符要么直接被编译器拒绝进行转换，要么就一定会得到相应的目标类型的值。 而dynamic\_cast却会进行判别，确定源指针所指的内容是否真的合适被目标指针接受。如果是否定的，那么dynamic\_cast则会返回null。这是通过检查"运行期类型信息"（Runtime type information，RTTI）来判定的，它还受到编译器的影响，有些编译器需要设置开启才能让程序正确运行。

## NOTE

1. const_cast<>不适用于迭代器的转换。因为其只是用于去掉类型前的限定符，而const_iterator和iterator是两个完全不同的类，其转换可以借助void advance(，int distance())的函数组合。

# 关于const与指针的识别方法：const后面的是常量。const type = type const

# 静态链接库和动态链接库

## GCC的工作流程

预处理(头文件展开、宏替换、去注释、条件编译等)->编译(检查语法生成汇编代码)->汇编(翻译为机器语言)->链接(决定库的载入方式)

## 静态库

1. 在链接阶段将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件。gcc加入-static参数即指定静态链接，使用ar程序创建静态库。
2. 优点：不依赖运行机器的库环境方便程序移植。
3. 缺点：文件大，修改需要重新全部打包，同一个库的代码在内存中可能有多份拷贝。

## 动态库

1. 程序运行过程中动态调用库文件，链接时仅仅在其中加入了所调用函数的描述信息。gcc默认为动态链接，-fPIC -shared控制生成静态库
2. 优点：可以增量更新，不浪费内存
3. 缺点：可移植性太差，严重依赖平台库环境

# STL容器

## 顺序容器(线性结构)：array、vector、list、forward\_list、deque

### vector

1. vector的理论存储上限可以调用max\_size得到。

* vector<bool>并不是一个STL容器，底层存储的并不是bool类型值，每个bool值都只使用一个比特位来存储。vector<bool>的operator[]返回的其实是一个代理对象，不满足容器要求的opertor[]返回指向元素的地址的要求。其本身是实验产物,注意在for循环中使用auto对vector<bool>遍历时,auto不会被推导为bool。

### deque

1. deque是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回。
2. deque由主控和存储区构成，通过主控维持整体连续的假象。所谓的主控是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指向另一段称作缓冲区的连续性内存空间的指针，缓冲区才是deque的存储空间的主体。
3. deque的实现决定了其迭代器复杂度和vector不是一个量级，并不适合直接使用算法中需要随机迭代器支持的算法。

## 有序关联式容器(红黑树)：set、multiset、map、multimap

* 红黑树是一种平衡二叉搜索树

1. 迭代器：由于红黑树本身有序，因此其迭代器可以视作对树的一种便利方法。
2. 由于红黑树任何一个结点都是独立的，修改其中一个结点不会影响到其他的元素在内存中的位置，所以对于关联容器插入删除都不会导致任何迭代器失效，除了指向被删除元素的迭代器。
3. set与map的区别在于所使用的红黑树的节点的具体类型有所不同，map使用了pair结构。
4. 红黑树提供的insert\_unique和insert提供了multi系列的支持。

## 无序关联式容器(哈希表)：unordered\_set、unordered\_multiset、unordered\_map、unordered\_multimap

* 上述四个容器的底层实现都依靠STL中的hash\_table与hase\_table\_node结构，其中hash\_table提供的insert\_unique和insert\_equal为multi系列依靠hash的容器提供了支持。

1. 标准库中哈希冲突的默认解决方法为链接法。
2. 哈希表中每个元素称为一个桶（bucket），每个被插入的元素利用哈希函数映射到对应的桶。为求得更好的性能，桶数量需要是质数，库通过打表加速质数的选择。为了能让桶数量动态增长，用vector作为桶的容器。
3. 所支持的都是前向迭代器，迭代器只支持operator++操作。

## 容器适配器：stack、queue、priority\_queue

1. 容器适配器本质上还是容器，只是为了特定的使用功能将基础容器中的函数实现进行了组合、优化或者重写。
2. 容器适配器的底层容器并不是固定的，STL对stack和queue默认使用deque实现，priority\_queue默认使用vector实现堆;

## 其它

1. assign与operator=：其基本作用都是为容器赋值，assign的使用更广一些。
2. at与operator[]：at提供边界检查，越界会抛出out\_of\_range异常。
3. array、vector、**deque**、string提供了随机访问迭代器支持的容器
4. map系列的容器支持按照key值删除元素
5. 算法的区间采用前开后闭的原因：可以统一空集的表示
6. list和forward\_list容器都根据自身实现提供了sort成员函数来加速排序。
7. string的size和length没有本质区别，length是为了保持C风格而保留的老式函数。
8. erase方法返回了指向被删除元素的下一个元素的迭代器。
9. vector和deque支持shrink\_to\_fit()自动紧缩内存

## 堆

STL中并没有直接的数据结构实现了堆，但却在vector的结构上实现了堆的一系列操作。

1. 基于vector建堆：make\_heap
2. 再对vector构成的堆变动之后的调整：push之后的push\_heap，pop之后的pop\_heap;
3. 对vector是否构成堆的判别操作：is\_heap以及找到破坏堆的is\_heap\_until

## 迭代器支持及失效情况

* [cppreference](https://zh.cppreference.com/w/cpp/container)底部提供了详细的各种容器的迭代器和引用在插入和操作后的失效情况说明,以及各容器支持的接口分布.

### 迭代器支持情况

|           不支持           |                             前向                             |               双向               |           随机            |
| :------------------------: | :----------------------------------------------------------: | :------------------------------: | :-----------------------: |
| stack,queue,priority_queue | forward_list,unordered_map,unordered_set,unordered_multimap,unordered_multiset | list,map,set,multi_map,multi_set | vector,string,array,deque |

### 迭代器及引用失效情况

1. 底层为数组的容器(vector,string)在插入删除点之后的失效(因为操作引起了存储转移),该点及之前的保持有效.
2. 底层为链表的容器 (list,forward_list)插入后均保持有效,删除后仅删除点失效.
3. 底层为红黑树 (map,set,multimap,multiset)插入后均有效,删除后除了删除点之外的均有效.
4. 底层为哈希表 ( unordered_map,unordered_set,unordered_multimap,unordered_multiset)在删除后除删除点之外均有效,插入后引用均合法,如果插入导致了重哈希则迭代器失效(少见).
5. deque在修改中部后迭代器和引用均失效,插入首尾失效,删除则仅操作点失效

# STL算法

## 查找算法(13个)：判断容器中是否包含某个值

1. adjacent\_find：   在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的 ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。
2. binary\_search： 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。
3. count：利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。
4. count\_if：利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。
5. equal\_range： 功能类似equal，返回一对iterator，第一个表示lower\_bound，第二个表示upper\_bound。
6. find：   利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。
7. find\_end：  在指定范围内查找"由输入的另外一对iterator标志的第二个序列"的最后一次出现。找到则返回最后一对的第一 个ForwardIterator，否则返回输入的"另外一对"的第一个ForwardIterator。重载版本使用用户输入的操作符代替等于操作。
8. find\_first\_of： 在指定范围内查找"由输入的另外一对iterator标志的第二个序列"中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。
9. find\_if：使用输入的函数代替等于操作符执行find。
10. lower\_bound：   返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。
11. upper\_bound：  返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。
12. search：  给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。
13. search\_n：  在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。

## 排序和通用算法(14个)：提供元素排序策略

1. inplace\_merge：  合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。
2. merge：合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。
3. nth\_element：  将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。
4. partial\_sort：对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。
5. partial\_sort\_copy： 与partial\_sort类似，不过将经过排序的序列复制到另一个容器。
6. partition： 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。
7. random\_shuffle：对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。
8. reverse：  将指定范围内元素重新反序排序。
9. reverse\_copy：与reverse类似，不过将结果写入另一个容器。
10. rotate： 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。
11. rotate\_copy：   与rotate类似，不过将结果写入另一个容器。
12. sort： 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。
13. stable\_sort：与sort类似，不过保留相等元素之间的顺序关系。
14. stable\_partition：与partition类似，不过不保证保留容器中的相对顺序。

## 删除和替换算法(15个)

1. copy：复制序列
2. copy\_backward： 与copy相同，不过元素是以相反顺序被拷贝。
3. iter\_swap：   交换两个ForwardIterator的值。
4. remove：删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove\_if函数。
5. remove\_copy： 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。
6. remove\_if：   删除指定范围内输入操作结果为true的所有元素。
7. remove\_copy\_if： 将所有不匹配元素拷贝到一个指定容器。
8. replace：将指定范围内所有等于vold的元素都用vnew代替。
9. replace\_copy： 与replace类似，不过将结果写入另一个容器。
10. replace\_if：   将指定范围内所有操作结果为true的元素用新值代替。
11. replace\_copy\_if： 与replace\_if，不过将结果写入另一个容器。
12. swap：   交换存储在两个对象中的值。
13. swap\_range：将指定范围内的元素与另一个序列元素值进行交换。
14. unique：清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。
15. unique\_copy：  与unique类似，不过把结果输出到另一个容器。

## 排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合

1. next\_permutation： 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。
2. prev\_permutation： 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用 自定义的比较操作。

## 算术算法(4个)

1. accumulate：iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。
2. partial\_sum：创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。
3. inner\_product：   对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。
4. adjacent\_difference： 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。

## 生成和异变算法(6个)

1. fill： 将输入值赋给标志范围内的所有元素。
2. fill\_n：将输入值赋给first到first+n范围内的所有元素。
3. for\_each：  用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。
4. generate：  连续调用输入的函数来填充指定的范围。
5. generate\_n： 与generate函数类似，填充从指定iterator开始的n个元素。
6. transform：将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。

## 关系算法(8个)

1. equal：  如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。
2. includes： 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的<操作符，成功返回true。重载版本使用用户输入的函数。>
3. lexicographical\_compare： 比较两个序列。重载版本使用用户自定义比较操作。
4. max： 返回两个元素中较大一个。重载版本使用自定义比较操作。
5. max\_element：  返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。
6. min：  返回两个元素中较小一个。重载版本使用自定义比较操作。
7. min\_element：返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。
8. mismatch：并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。

## 集合算法(4个)

1. set\_union：构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。
2. set\_intersection： 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。
3. set\_difference：构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用  自定义的比较操作。
4. set\_symmetric\_difference： 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。

## 堆算法(4个)

1. make\_heap： 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。
2. pop\_heap：   并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被"弹出"的元素或者使用pop\_back进行真正的删除。重载版本使用自定义的比较操作。
3. push\_heap： 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。
4. sort\_heap：  对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。

# STL仿函数与仿函数适配器

## 仿函数

1. 算术类仿函数(6个)：plus、minus、multiplier、divides、modulus、negate(取相反数)
2. 关系运算仿函数(6个)：less、less\_equal、equal\_to、not\_equal\_to、greater\_equal、greater\_equal\_to
3. 逻辑运算仿函数(3个)：logical\_and、logical\_or、logical\_no

## 函数适配器

* 能够将仿函数和另一个仿函数（或某个值，或某一个函数）结合起来的仿函数。声明于<functional>中。
* C++11/C++17/C++2x弃用了大量的函数适配器

# STL空间配置器

1. 出现背景：大量且频繁的小块内存非配带来了大量碎片，以及申请释放时的系统调用造成的性能损失。
2. 内存池：缓解小块内存分配带来的问题，基本的思想是一次向heap申请一块很大的内存(内存池)，如果申请小块内存的话就直接到内存池中去取。
3. 作用：完成内存配置与释放，对象构造和析构的工作。责任主体为allocator，其四大助手为allocate，deallocate，construct和destroy。
4. STL实现了std：：allocator(效率低，简单包装了new和delete，只为兼容老代码)和std：：alloc(实际使用的版本)

## 组成结构

1. 概述：一级空间配置器(大块(>128B)内存分配，封装了malloc与free)和二级空间配置器(重点，小块(<=128B)的在内存池分配)。

### 一级空间配置器

1. 首先尝试使用malloc分配内存
2. 如果空间不满足调用内存不足处理函数
3. 内存处理函数如果没有设置相应的处理函数，则抛出bad\_alloc异常。否则循环调用处理函数直到成功。

* **注意**："内存不足处理机制"是客户端的责任，设置"内存不足处理介质"也是客户端的责任。

### 二级空间配置器

1. 支持结构：堆内存池与free\_list(16个链表首指针构成free\_list数组，每个链表分别组织已从内存池分配的N×8B的空闲内存块(为了便于管理，在内存池上的分配以8B为基本单位))。

#### 分配策略

1. 首先尝试在free\_list上寻找最小可满足内存块(其大小为n)，如果不满足调用refill从内存池申请
2. refill尝试从内存池分配max{1-20}个(STL默认一次申请多个)大小为n的内存块，如果得到满足，首先返回一个给上层调用，其余的挂到大小为n的free\_list的元素的链表后面。
3. 如果第二步得不到满足(内存池可用<n)，先将内存池中的剩余可用块挂到相应的free\_list的相应节点链表后面，再向堆空间申请内存。
4. 如果第三步成功，再次执行第二步。否则在free\_list寻找大于n的内存，有则将这一块内存归还到内存池，之后进行第二步，否则调用一级空间配置器。

## 缺点

1. 二级空间配置器造成的内碎片问题(尤其时频繁申请char这种小内存时)。
2. 二级空间配置器将空闲的内存一直自己持有没有回收给系统，可能造成堆存储不做或者二级配置器无法满足稍大一点的内存需求等问题。

# STL迭代器

1. 迭代器是一种抽象的设计概念，它提供一种方法，使之能够依序访问某个聚合物所含的各个元素，从而无需暴露该聚合物的内部表述方式。
2. 优化思想：利用C++重载机制和参数推导机制(traits，类型萃取)将运行期决议问题提前到编译期决议，实现了避免在运行时判断迭代器的类型。

## 萃取器

1. 思想：提供一个统一的接口，通过这个接口可以获取对象/数据的类型，其他的容器实现这一接口

### 迭代器相关的类型萃取

1. value_type： 代表迭代器所指对象的类型。
2. difference_type：代表两个迭代器之间的距离
3. reference_type：代表迭代器所指对象的引用类型。简言之，它是operator*()的返回类型
4. pointer_type：代表迭代器所致对象的指针类型。简言之，它是operator->()的返回类型
5. iterator_category：代表1中提出的五种迭代器的类型标识

### 在迭代器中的应用和实现

1. 原生指针：利用模板类的偏特化，为原生的指针和const指针提供iterator_traits。
2. 一般迭代器：在数据结构中的实现里，统一提供一个接口来标明自己的数据类型来供外部访问。

## 类别

### 基本迭代器类型

* 输入/出(i/ostream)、前(forward\_list，unordered\_<multi>[map|set])/双向(list，<multi>[map|set])、随机(vector，array，string，deque，内置指针数组)迭代器。

### 迭代器适配器

#### 插入适配器

1. 插入适配器inserter：要求容器有insert成员函数，如vector，list，map，set，deque(有点破换deque数据结构)， inserter()可以快速创建该类型迭代器，参数中的位置参数仅做指示作用。
2. 前向插入适配器front\_insert\_iterator：要求类有push_front函数支持，如list和deque。可以借助front\_inserter()快速创建。
3. 后向插入迭代器back\_insert\_iterator：要求成员函数push\_back支持，如vector、list、deque。可以借助back\_inserter()创建。

### 流适配器

1. 输出流迭代器适配器ostream_iterator
2. 输入流迭代器适配器istream_iterator，含输入序列结束标志判断。
3. 输出流缓冲迭代器ostreambuf_iterator
4. 输入流缓冲迭代器istreambuf_iterator

* 输入输出迭代器的思想是将输入输出流当作序列，ostream_iterator和istream_iterator相当于指向序列的迭代器，用户可以通过这个迭代器对输入输出流做操作。
* ostream_iterator只支持写操作(*p=X)和迭代操作(++)；**istream_iterator支持读(=*p)， 访问(->)，迭代(++)，比较(==， !=)操作。
* istreambuf_iterator和ostreambuf_iterator可以使用户跨过iostream，直接跟流缓冲区打交道。
* 流缓冲区迭代器和流迭代器最大的区别在于，前者仅会将元素**以字符的形式（包括char、wchar_t、char16_t及char32_t等）**读或者写到流缓冲区中，由于不会涉及数据类型的转换，读写数据的速度比后者要快。

### 逆向迭代器适配器

1. reverse_iterator：

### 移动迭代器

1. move_inserter：C++11引入。可以实现以移动而非复制的方式，将某个区域空间中的元素移动至另一个指定的空间。

* 调用make_move_iterator函数可以由基础迭代器快速创建move_iterator迭代器.
* 此基础迭代器的类型虽然没有明确要求，但该模板类中某些成员方法的底层实现，需要此基础迭代器为双向迭代器或者随机访问迭代器。
* 通过移动迭代器将容器中某区域的元素移动到了其他容器中，该区域内仍可能残留有之前存储的元素，但这些元素是不能再被使用的，否则极有可能使程序产生各种其他错误。

## 迭代器的移动

1. advance：参数本身被改变，迭代器至少为单向迭代器，当步数参数小于0则必须是双向迭代器。
2. prev：不改变参数。获取一个距离指定迭代器 n 个元素的迭代器。要求为双向或者随机迭代器。**自身不会检验新迭代器的指向是否合理**
3. next：不改变参数。迭代器类型要求同1，单向迭代器只能用正参数。**也不会检查新迭代器指向的有效性**。

## 指针、引用和迭代器

* 引用的本质在大多数时候是一个被施加了许多限制的指针(在面对右值可以延长其生命器)，通过这些语法上的限制规避了使用裸指针时的一些危险性为，其效率和裸指针相同。
* 迭代器是模仿指针的行为设计的类模板，是对指针概念的一种提升。指针也可以被视为一种迭代器。迭代器更像是一组抽象的接口，满足了这一组接口就可以称之为迭代器，满足这些接口的具体实现方法高度依赖于实际的数据结构。

# 类型推导

## auto

* 背景：auto作为变量存储关键字长期以来并没有发挥大的作用，C++11决定用auto依据初始值实现编译期的类型推导
* note：auto仅仅是一个占位符，在编译期间会自动推导出变量的类型，C++中的变量依然有明确的类型。
* note：auto表达式推导出的类型和auto被替换时的类型不同，被替换成的字符转只是最终类型的一部分。

### 用法

* 由于auto用来做类型推导，所以auto类型的变量必须在声明的时候进行初始化。

1. 当一个auto修饰多个变量时，变量推导出的类型不能有冲突。
2. auto与*和&混用：此时auto被推导为不带指针或引用的类型，但是auto声明的变量的类型为auto+cv限定符。
3. 当auto的=右边的表达式是一个引用类型时，auto 会把引用抛弃，直接推导出它的原始类型。
4. auto与const的结合：当左边的类型声明含有引用或者指针符号时，推导出的最终类型含有const属性，否则const被去除。

### 限制

1. 不能做函数参数(C++11不允许;C++14已经允许，但是在设置默认参数可能无法匹配)
2. 不能作用于类的非静态成员变量(类的静态成员变量似乎也不行，没实验成功)。？？？？？？？？？？？？？？？？？？
3. 不能用于定义数组，即不能是auto var[]的形式。
4. 不能作用于模板参数，但在泛型编程中可以得到大量应用。

## decltype

* 背景：C++11新增，根据表达式(必须有类型)参数完成编译期的类型推导。

### decltype(exp)推导规则

1. 如果exp是一个不被括号( )包围的表达式，或者是一个类成员访问表达式，或者是一个**单独的**变量，那么decltype(exp)的类型就和exp一致。
2. 如果exp是函数调用(形式要满足函数调用，但是不会被执行)，那么decltype(exp)的类型就和函数返回值的类型一致。
3. 如果exp是一个左值表达式(注意与1中的单独的变量区分)，或者被括号( )包围，那么decltype(exp)的类型就是exp的引用。

## auto与decltype的不同

### 对cv限定符(const、volatile)的处理

* auto：如果表达式的类型是指针或者引用，保留cv限定符，否则丢弃限定符。
* decltype：保留cv限定符

### 对引用的处理

1. decltype 会保留引用类型.
2. auto会抛弃引用类型，直接推导出它的原始类型。

### 总结

* auto书写简单、推导复杂(有时会改变原始类型)。decltype书写复杂、推导简单

## template参数推导：无法用于函数返回类型

## 声明内嵌型别：无法处理原声指针

## traits(类型萃取)

* 基本思想：加入中间层，为下层提供接口，为上层提供服务。
* 实现：内嵌类别处理非基础数据类型，骗特化提供原生指针支持。函数模板对于原生指针和自定义 iterator 的定义都统一起来，解决原生指针和自定义 iterator 之间的不同所造成的代码冗余。

# lambda表达式/闭包

* 形式：[capture] <(parameters) mutable noexcpt/throw() -> return_type> { body }，尖括号内可选，但param和mutable以及异常管理中的任意多个必须同时出现。
* 本质：函数对象，内部创建了一个重载()操作符的类。
* 大致原理：在C++中，lambda表达式是函数对象的语法糖，每当定义一个lambda表达式，编译器会自动生成一个匿名类（重载了()运算符），也称为闭包类型（closure type）。在运行时，lambda表达式就会返回一个匿名的闭包实例。

## 形式说明

### 捕获变量列表

1. [<[ ，=，&][var]>]：<>内前半部分的三个符号可以与var随意结合/不结合用来表示捕获变量的方式。为空则不捕获任何变量，=表示值捕获，&为引用捕获，与var结合表示对该变量使用结合的捕获方式，不结合表示捕获在表达式内部被用到的全部变量，单独var表示值捕获。通用的捕获在捕获列表前部，特殊捕获在后，以逗号分割。
2. 变量来源：使用那些**到定义Lambda为止时**Lambda所在作用范围内可见的局部变量(包括Lambda所在类的this)。非局部变量，如静态变量、全局变量等可以不经捕获，直接使用；
3. 捕获时机：lambda被声明时而非运行时，对于引用则是运行时在访问外部。
4. 捕获this：只有包含且最靠近lambda表达式的函数不是静态成员函数时才能被捕获this。在C++17之前只能通过引[this]以引用捕获当前对象（其实是复制指针），c++17以后可以通过[*this]进行值捕获。捕获之后lambda 表达式拥有和当前类成员函数同样的访问权限、控制权限和访问方式。

#### 其他说明

1. note：如果一个闭包含有局部变量的引用，在超出创建它的作用域之外的地方被使用的话，这种行为是未定义的!
2. 捕捉列表不允许变量重复传递

### parameters

1. 不支持默认参数、不支持可变参数、不支持匿名参数。

### multable

1. 背景：对于值捕捉方式，类会相应添加对应类型的非静态数据成员，在运行时会用复制的值初始化这些成员变量，从对于引用捕获的变量，标准中没有规定其在类中的表示方法。
2. 重载的operator()方法默认是const限定的，无法修改值传递后构建的成员。而对于引用的传递方式，并不会改变引用本身，而只会改变引用的值，因此就可以改变。
3. 作用：mutable关键字可以使重载的operator()函数丢弃函数声明末尾的const限定符，从而修改传递进来的拷贝。

### noexcept/throw()

* noexcept表示不抛出遗产，throw表示只抛出指定类型的异常。

### return\_type

* 当返回值为 void，或者函数体中只有一处return(此时编译器可以自动推断出返回值类型)时，这部分可以省略。

## 其它

1. lambda禁用了赋值操作符，但是可以使用拷贝构造函数(可以用已有的lambda表达式初始化新的lambda表达式)。
2. lambda可以赋值给具有相同形式的函数指针
3. 如果lambda的生存期长于捕获的对象，则可能导致悬空引用的问题。
4. 利用lambda的立即调用实现的[magic](https：//lesleylai.info/zh/c++-lambda/)，推荐这位[博主](https：//lesleylai.info/zh)
5. 没有捕获变量的lambda表达式可以直接转换为函数指针，而捕获变量的lambda表达式则不能转换为函数指针。

## C++14新特性

1. 通用捕获：带有初始化器的捕获符，实例：[x = 1]{ return x; // 1 }
2. 使用通用捕获捕获仅可移动的类型，实例：unique\_ptr<T> x = ...; [u=move(u)] {  do_something_with( u );}
3. 泛型lambda表达式：参数可以使用自动推断类型的功能，而不需要显示地声明具体类型。
4. 表达式捕捉：允许用任何类型的表达式初始化捕捉的变量(与1，2相关)。

# 其他

## C++11引入nullptr用来初始化所有指针类型变量

## 构造函数初始化列表

1. 必用情况：const成员或引用类型的成员、成员类型是没有默认构造函数的类。
2. 好处：C++在进入构造函数的函数体之前已经完成对类数据成员的构造。使用初始化列表可以一步构建出成员，而函数体内的赋值初始化进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成。
3. 初始化顺序：按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序。

## endl、"\n"和缓冲区

1. 结论：endl和\n可以达到相同的效果，但前者的实现效率比较低。
2. 原因：在于endl是一个函数调用，而且在函数内向先向缓冲后加入"\n"后调用刷新函数flush强制输出缓冲。

## 后缀形式的自增/减重载接受一个无用的int 形参来与前缀形式区分

## const与constexpr

* C++11为了解决const具有的只读和常量的双重语义造成的歧义问题，引入了constexpr来承接常量。
* const和constexpr都可以修饰数据、函数、表达式，且大多场景下可以相互替代。

### const

* const变量的初始化可在编译期初始化，也可以在运行时初始化。

### constexpr

* constexpr修饰的函数如果编译期可以确定就确定，否则的话函数成为普通函数。所以如果函数体适用于constexpr函数的条件，可以加上constexpr。
* constexpr修饰的变量的值必须在编译时就能确定。
* constexpr修饰的变量类型只能是基本数据类型、指针、引用和自定义数据类型(需满足要求)，不能是其它标准库类型。
* constexpr可以修饰函数模板，如果其实例化版本不满足constexpr则函数自动退化为普通函数。

#### constexpr函数表达式要求

* constexpr函数隐式的声明为const函数。

1. 被修饰的函数必须在使用之前被定义。
2. 函数只有一条return语句(c++11要求，C++14放开)，static_assert， using， typedef等不会产生实际代码的语句在函数中可以使用。
3. 函数必须有返回值且必须是一个常量表达式(不能使用非常量表达式的函数，全局数据)。

#### constexpr自定义数据类型要求

1. 自定义常量构造函数+空函数体+初始化列表由常量表达式赋值

## C++11解决了连续右尖括号>>的歧义问题

# 强烈推荐用[网站](https：//cppinsights.io/)翻译代码，验证自己的想法

* 尤其是auto、decltype、lambda等一些章节
