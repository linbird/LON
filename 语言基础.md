# 目录

<!-- vim-markdown-toc GFM -->

+ [内存管理](#内存管理)
    * [标准库支持](#标准库支持)
    * [new(new operator)的实现](#newnew-operator的实现)
        - [概述](#概述)
        - [operator new()](#operator-new)
            + [重载operator new/new[]](#重载operator-newnew)
        - [placement new](#placement-new)
            + [作用](#作用)
            + [本质与实现](#本质与实现)
            + [NOTE](#note)
            + [使用](#使用)
        - [new 与 malloc 的区别](#new-与-malloc-的区别)
+ [多态](#多态)
    * [动态多态](#动态多态)
        - [设计思想](#设计思想)
        - [实施条件](#实施条件)
        - [实施机制(虚函数与虚函数表)](#实施机制虚函数与虚函数表)
            + [虚函数表内容](#虚函数表内容)
            + [继承下的虚函数表](#继承下的虚函数表)
            + [虚函数与纯虚函数](#虚函数与纯虚函数)
        - [优点](#优点)
        - [缺点](#缺点)
    * [静态多态](#静态多态)
        - [设计思想](#设计思想-1)
        - [优点](#优点-1)
        - [缺点](#缺点-1)
+ [智能指针(smart\_ptr)](#智能指针smart_ptr)
    * [几种智能指针(>=C++11)](#几种智能指针c11)
+ [右值引用](#右值引用)
    * [右值引用](#右值引用-1)
    * [万能引用](#万能引用)
    * [移动语义与完美转发](#移动语义与完美转发)
        - [move和forward](#move和forward)
    * [几种类型的绑定问题](#几种类型的绑定问题)
    * [关于返回值类型](#关于返回值类型)
        - [RVO](#rvo)
        - [手动优化](#手动优化)
+ [类型转换](#类型转换)
    * [传统类型转换](#传统类型转换)
    * [标准类型转换](#标准类型转换)
    * [建议](#建议)
    * [NOTE](#note-1)
+ [静态链接库和动态链接库](#静态链接库和动态链接库)
    * [GCC的工作流程](#gcc的工作流程)
    * [静态库](#静态库)
    * [动态库](#动态库)
+ [STL容器](#stl容器)
    * [顺序容器(线性结构)：array、vector、list、forward\_list、deque](#顺序容器线性结构arrayvectorlistforward_listdeque)
        - [vector](#vector)
        - [deque](#deque)
    * [有序关联式容器(红黑树)：set、multiset、map、multimap](#有序关联式容器红黑树setmultisetmapmultimap)
    * [无序关联式容器(哈希表)：`unordered\_set、unordered\_multiset、unordered\_map、unordered\_multimap`](#无序关联式容器哈希表unordered_setunordered_multisetunordered_mapunordered_multimap)
    * [容器适配器：`stack、queue、priority\_queue`](#容器适配器stackqueuepriority_queue)
    * [其它](#其它)
    * [堆](#堆)
    * [迭代器支持及失效情况](#迭代器支持及失效情况)
        - [迭代器支持情况](#迭代器支持情况)
        - [迭代器及引用失效情况](#迭代器及引用失效情况)
+ [STL算法](#stl算法)
    * [查找算法(13个)：判断容器中是否包含某个值](#查找算法13个判断容器中是否包含某个值)
    * [排序和通用算法(14个)：提供元素排序策略](#排序和通用算法14个提供元素排序策略)
    * [删除和替换算法(15个)](#删除和替换算法15个)
    * [排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合](#排列组合算法2个提供计算给定集合按一定顺序的所有可能排列组合)
    * [算术算法(4个)](#算术算法4个)
    * [生成和异变算法(6个)](#生成和异变算法6个)
    * [关系算法(8个)](#关系算法8个)
    * [集合算法(4个)](#集合算法4个)
    * [堆算法(4个)](#堆算法4个)
+ [STL仿函数与仿函数适配器](#stl仿函数与仿函数适配器)
    * [仿函数](#仿函数)
    * [函数适配器](#函数适配器)
+ [STL空间配置器](#stl空间配置器)
    * [组成结构](#组成结构)
        - [一级空间配置器](#一级空间配置器)
        - [二级空间配置器](#二级空间配置器)
            + [分配策略](#分配策略)
    * [缺点](#缺点-2)
+ [STL迭代器](#stl迭代器)
    * [类别](#类别)
        - [基本迭代器类型](#基本迭代器类型)
        - [迭代器适配器](#迭代器适配器)
            + [插入适配器](#插入适配器)
            + [逆向迭代器适配器](#逆向迭代器适配器)
            + [移动迭代器](#移动迭代器)
    * [迭代器的移动](#迭代器的移动)
    * [指针、引用和迭代器](#指针引用和迭代器)
+ [STL正则表达式](#stl正则表达式)
    * [构成](#构成)
        - [正则表达式regex](#正则表达式regex)
        - [搜索匹配算法](#搜索匹配算法)
        - [结果匹配集](#结果匹配集)
    * [实例](#实例)
+ [CPP IO处理](#cpp-io处理)
    * [基本流对象](#基本流对象)
        - [文件流](#文件流)
            + [流指针](#流指针)
            + [行结束标志](#行结束标志)
    * [缓冲](#缓冲)
        - [缓冲区](#缓冲区)
        - [应用](#应用)
            + [IO加速](#io加速)
            + [流同步](#流同步)
            + [流关联](#流关联)
        - [影响](#影响)
            + [\n与缓冲刷新](#n与缓冲刷新)
            + [诡异的std::cin](#诡异的stdcin)
    * [流相关迭代器](#流相关迭代器)
        - [输入流迭代器istream_iterator](#输入流迭代器istream_iterator)
        - [输出流迭代器ostream_iterator](#输出流迭代器ostream_iterator)
        - [输出流缓冲迭代器ostreambuf_iterator](#输出流缓冲迭代器ostreambuf_iterator)
        - [输入流缓冲迭代器istreambuf_iterator](#输入流缓冲迭代器istreambuf_iterator)
+ [类型推导](#类型推导)
    * [auto](#auto)
        - [用法](#用法)
        - [限制](#限制)
    * [decltype](#decltype)
        - [decltype(exp)推导规则](#decltypeexp推导规则)
    * [auto与decltype的不同](#auto与decltype的不同)
        - [对cv限定符(const、volatile)的处理](#对cv限定符constvolatile的处理)
        - [对引用的处理](#对引用的处理)
        - [总结](#总结)
    * [traits(类型萃取)](#traits类型萃取)
        - [迭代器相关的类型萃取](#迭代器相关的类型萃取)
        - [在迭代器中的应用和实现](#在迭代器中的应用和实现)
+ [lambda表达式/闭包](#lambda表达式闭包)
    * [形式说明](#形式说明)
        - [捕获变量列表](#捕获变量列表)
            + [其他说明](#其他说明)
        - [parameters](#parameters)
        - [multable](#multable)
        - [noexcept/throw()](#noexceptthrow)
        - [return\_type](#return_type)
    * [其它](#其它-1)
    * [CPP14 lambda表达式增强](#cpp14-lambda表达式增强)
+ [类相关](#类相关)
    * [权限控制](#权限控制)
        - [外部访问控制](#外部访问控制)
        - [特殊权限控制](#特殊权限控制)
            + [构造函数private化](#构造函数private化)
                * [影响](#影响-1)
            + [构造函数protect化](#构造函数protect化)
                * [影响](#影响-2)
            + [析构函数private化](#析构函数private化)
                * [影响](#影响-3)
    * [初始化方法](#初始化方法)
        - [初始化列表](#初始化列表)
        - [就地初始化](#就地初始化)
        - [列表初始化list\_initialization](#列表初始化list_initialization)
            + [聚合体](#聚合体)
            + [std::initializer\_list](#stdinitializer_list)
        - [委托构造函数](#委托构造函数)
            + [异常处理](#异常处理)
    * [函数](#函数)
        - [The Big Three](#the-big-three)
        - [编译器自动生成的函数(4+2)](#编译器自动生成的函数42)
            + [生成内容](#生成内容)
            + [生成规则](#生成规则)
            + [函数生成管理](#函数生成管理)
                * [使用缺省函数=default](#使用缺省函数default)
                * [禁止函数=delete](#禁止函数delete)
                * [禁止构造函数类型转换explicit](#禁止构造函数类型转换explicit)
        - [自增/减运算符重载](#自增减运算符重载)
        - [inline函数](#inline函数)
    * [friend成员](#friend成员)
    * [继承](#继承)
        - [虚函数](#虚函数)
        - [限制继承final](#限制继承final)
        - [继承下的访问控制](#继承下的访问控制)
        - [继承的内容](#继承的内容)
                * [继承除赋值运算符重载](#继承除赋值运算符重载)
                * [继承构造函数](#继承构造函数)
        - [虚继承](#虚继承)
            + [实现原理](#实现原理)
            + [NOTE](#note-2)
+ [关键字补充说明](#关键字补充说明)
    * [cv限定符](#cv限定符)
        - [const](#const)
            + [const与指针](#const与指针)
        - [volatile](#volatile)
            + [使用场景](#使用场景)
    * [constexpr](#constexpr)
        - [背景](#背景)
        - [constexpr使用要求](#constexpr使用要求)
            + [对编译的影响](#对编译的影响)
            + [constexpr修饰函数/表达式](#constexpr修饰函数表达式)
            + [constexpr修饰变量](#constexpr修饰变量)
+ [PIML(pointer to implementation)](#pimlpointer-to-implementation)
+ [重载、覆盖和改写(隐藏)](#重载覆盖和改写隐藏)
+ [异常处理](#异常处理-1)
    * [函数的异常声明列表](#函数的异常声明列表)
    * [异常种类](#异常种类)
        - [标准异常](#标准异常)
+ [线程和原子操作](#线程和原子操作)
    * [线程 thread](#线程-thread)
        - [线程创建](#线程创建)
        - [线程结束](#线程结束)
            + [绑定式 join()](#绑定式-join)
            + [分离式 detach()](#分离式-detach)
    * [原子操作 atomic](#原子操作-atomic)
        - [内置原子操作类型](#内置原子操作类型)
+ [C++其它部分新特性](#c其它部分新特性)
    * [C++ 11](#c-11)
        - [tuple容器(CPP11)](#tuple容器cpp11)
        - [decltype后置返回类型](#decltype后置返回类型)
        - [新初始化机制](#新初始化机制)
            + [就地初始化](#就地初始化-1)
            + [列表初始化](#列表初始化)
            + [委托构造函数](#委托构造函数-1)
        - [外部模板(CPP11)](#外部模板cpp11)
        - [编译时的多重尖括号](#编译时的多重尖括号)
        - [using定义类型别名](#using定义类型别名)
        - [nullptr](#nullptr)
    * [C++14](#c14)
        - [auto实现返回类型自动推导](#auto实现返回类型自动推导)
        - [lambda表达式](#lambda表达式)
    * [C++17](#c17)
        - [结构化绑定(CPP17)](#结构化绑定cpp17)
            + [绑定方式(所声明的变量的形式)](#绑定方式所声明的变量的形式)
+ [强烈推荐用网站翻译代码，验证自己的想法](#强烈推荐用网站翻译代码验证自己的想法)

<!-- vim-markdown-toc -->

# 内存管理

## 标准库支持

+ 标准库为`operator new/new[]和operator delete/delete[]`分别提供了抛出和不抛出异常的重载版本。用户可以在全局作用域或类作用域定义自己的重载并实现。
+ note:`new[]`与`delete[]`需要成对使用，原因在于这一对函数是为对象数组服务的。`new[]`为了保存数组的大小信息，在申请内存时多申请了4B(32bit下)放在首部来存储长度信息，而delete也需要长度信息来确定调用析构函数的次数

## new(new operator)的实现

### 概述

+ 具体实现方法没有一定之规

1. 调用`operator new`函数（`new[]`调用的时`operator new[]`函数）分配一块足够大的未命名的原始内存空间。
2. 编译器调用类的构造函数构造对象，传入初值。
3. 完成对象构造后返回对象指针。

### operator new()

+ `operator new()`只分配所要求的空间，调用相关对象的构造函数初始化空间由`new operator`在`operator new`返回之后完成。

+ `operator new()`可以在不能分配内存而返回异常（是否返回异常取决于是否有`nothrow`参数）之前通过`set_new_handler()`指定的回调函数`void new_handler(void)`完成一些操作(可以先释放一些空间，然后再尝试申请空间)。

#### 重载operator new/new[]

+ C++标准规定`new operator`与`delete operator`的行为是不能够也不应该被改变，只有`operator new`与`operator delete`允许被重载。
+ 要求：重载可以带其他参数、第一参数必须是表示要求分配的空间大小的`size_t`类型、返回值必须是`void*`类型。

### placement new

#### 作用

+ 借助它可以在传入指针指向的内存空间(堆、栈甚至静态存储区)上构造对象。
+ 由于是在已经预先准备好的内存中分配内存，避免了查找可用内存空间和一些系统调用，非常适合那些对时间要求比较高，长时间运行不希望被打断的应用程序。

#### 本质与实现

+ 只是`operator new`的一个重载版本
+ 它并不分配内存，返回指向已经分配好的某段内存的一个指针，这个指针指向了给对象分配的内存空间（已初始化）。

#### NOTE

+ 利用`placement new`实现的对象不能使用`delete`系列函数释放空间(这个内存不一定是`new`动态申请的），但是这一类对象必须显式调用类的析构函数。但是如果所使用的空间是在堆上分配的，在程序结束时一定要释放这块堆内存。

#### 使用

  ```cpp
class X{
public:
    X() { cout<<"constructor of X"<<endl; }
    ~X() { cout<<"destructor of X"<<endl;}
    void function(int n) {}
};

int main(){
    char* buf = new char[sizeof(X)]; //1:分配内存buf（堆上、栈上或者直接指向有意义的地址都可）
    X *px = new(buf) X;     //2:在刚才已分配的缓存区调用placement new来构造一个对象。
    px->function(10);     //3:按照普通方式使用分配的对象。
    px->~X();       //4:使用完这个对象就显式调用它的析构函数\。
    delete []buf;      //5:释放buf(取决于1)
    return 0;
}
  ```

### new 与 malloc 的区别

|            |         new operator          |      malloc      |
| :--------: | :---------------------------: | :--------------: |
|  分配大小  |       自动计算类型大小        |     参数指定     |
| 对象初始化 |     自动调用构造函数完成      | 不支持自动初始化 |
|  异常处理  | `bad_alloc`或者构造函数的异常 |      不支持      |
|   返回值   |     对象类型的指针或异常      | void\*指针或null |
|  内存调整  |       借助`realloc`函数       |      不支持      |

+ `realloc`：如果原指针指向的空间有足够的连续空间则原地扩大可分配的内存地址返回原指针，否则寻找满足长度的连续内存空间并将数据拷贝到新空间返回新空间首地址并释放原地址空间

# 多态

多态指的是对同一接口调用会表现出不同行为的一种现象。可分为静态多态和动态多态：

## 动态多态

+ 又称运行时多态、晚绑定[基类虚函数定义接口，继承类负责实现]。实现方法为虚函数

### 设计思想
+ 在基类中把多个相关的对象共同的功能声明为多个公共的虚函数接口。各个子类重写这些虚函数以完成具体的功能。客户端的代码（操作函数）通过指向基类的引用或指针来操作这些对象，对虚函数的调用会自动绑定到实际提供的子类对象上去。
+ 只有当程序运行时才能最终确定调用的具体的方法

### 实施条件

1. 含有虚函数的基类
2. 继承自虚基类的子类，子类和基类的成员函数签名完全相同(返回值、函数名、参数列表)
3. 将子类对象的指针或者引用赋值给基类类型的指针或引用并以此调用虚函数

### 实施机制(虚函数与虚函数表)
+ 对于含有虚函数的基类，其对象的空间的最前面会占用一个地址长度来保存一个地址，该地址指向类的虚函数表

#### 虚函数表内容

+ 每个类有一个或多个虚函数表（不同编译器实现有差别），对象只持有指向虚函数表的地址。而一个基类的多个子类实例在调用同一函数时之所以表现不同，是因为类的成员函数在编译时被编译器自动在参数列表中加入了this指针参数，不同对象的this指针各不相同，通过虚函数表最终确定的函数地址也不相同。
+ 虚函数表中的每一个表项记录了虚函数的地址，表的末尾项标记了表是否结束。
+ 表项按照虚函数的申明顺序存放。

#### 继承下的虚函数表

1. 单继承无重写：则表无覆盖，子类的虚函数表项接到父类的表项之后。
2. 单继承有重写：子类重写的虚函数地址会覆盖父类中被重写的虚函数的表项，其他子类虚函数表项接到后面。
3. 多继承无重写：子类含有多个虚函数表和多个(linux/g++)虚函数表指针。子类的虚函数表项被放在第一个申明的基类的虚函数表项的后边构成一张表，其余基类的虚函数表被依次放到后边，此时子类持有多个虚函数表。
4. 多继承有重写：子类重写的虚函数地址会覆盖所有基类中被重写的虚函数的表项，其余同第三条。
5. 有虚函数的虚继承：
6. 无虚函数的虚继承：

#### 虚函数与纯虚函数

1. 虚函数：

+ 思想：**希望**子类可以各自为自己父类提供的虚函数提供个性化的实现，当子类没有实现时可以使用父类的缺省实现。
+ 由思想可知虚函数必须提供实现

2. 纯虚函数：

+ 思想：**强制**子类必须提供纯虚函数的个性化实现，否则子类还是一个纯虚基类。
+ 申明在基类中的不需要实现的虚函数(这样的类被称为抽象类，不能实例化对象)，纯虚函数在派生类中定义以后，派生类才能实例化出对象。
+ 如果不加显式约束的话，基类的纯虚函数在子类中自动变为了虚函数。

### 优点

1. 分离了接口与实现，方便了复用;便于处理同一继承体系下的异质对象

### 缺点

1. 运行时绑定有开销;编译器无法优化虚函数;不方便修改接口

## 静态多态

+ 又称编译器多态、早绑定[模板定义接口，类型参数定义实现]。实现的方法有函数重载以及模板

### 设计思想
+ 对于相关的对象类型，直接实现它们各自的定义，不需要共有基类，甚至可以没有任何关系。只需要各个具体类的实现中要求相同的接口声明，这里的接口称之为隐式接口。客户端把操作这些对象的函数定义为模板，当需要操作什么类型的对象时，直接对模板指定该类型实参即可（或通过实参演绎获得）。
+ 系统在编译期就可以确定程序将要执行哪个函数。

### 优点

1. 早绑定效率高，编译器可以优化;可以通过特化处理特殊类型;方便了泛型编程

### 缺点

1. 借助模板实现的多态代码膨胀、编译耗时、调试困难;不能处理异质对象（就是存储、指向类型不一致的数据对象，例如基类下的几个子类）

# 智能指针(smart\_ptr)

1. 设计目的：为了避免使用原声指针不当造成的内存泄漏(忘记释放)以及非法引用(被提前释放内存)的问题，设计智能指针概念来自动管理内存，其具有指针的行为(解引用等)。
2. 设计思想：RAII(Resource Acquisition is Initialization)使用类来管理(而非拥有)资源，将资源和对象的生命周期绑定，也就是说在构造函数中申请分配资源，在析构函数中释放资源。
3. 实现原则：智能指针对象作为普通变量被分配在栈空间，当智能指针对象离开作用域或者其引用失效时，智能指针对象自动调用其析构函数来管理对象所持有的资源。

## 几种智能指针(>=C++11)

1. `auto_ptr`(已弃用)：C++98的方案，C++11已经抛弃。采用排它所有权模式，当出现语法中允许的拷贝构造和赋值时，资源所有权会由源对象转移到新对象中，此时再使用源对象时会空引用，为了解决问题设计了`unique_ptr`。此外`auto_ptr`在析构中使用的`delete`也不能管理动态开辟的数组。
2. `unique_ptr(scoped_ptr)`：**独占资源所有权**实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象(在语义上禁止了拷贝构造和赋值运算[库申明而不实现这两个函数，且被private保护]，但是允许用右值进行赋值)。`boost::scoped_ptr`是一个不允许转移所有权独占性智能指针。
3. `shared_ptr`：**共享资源所有权**，多个对象共用一个引用计数(库实现了对计数的原子操作)记录内存单元被引用的次数。除了可以通过new、传入`auto_ptr、unique_ptr、weak_ptr`来构造，调用`release()`时当前指针会计数减一，计数等于0时释放资源。无法解决循环引用问题。
4. `weak_ptr`：**能访问资源，但不控制生命周期**。它指向一个`shared_ptr`管理的对象，进行该对象的内存管理的是强引用的`shared_ptr，wake_ptr`作为`shared_ptr`的观察者，其构造和析构不会改变強引用的计数。和shared_ptr配合用来解决循环引用。但由于`wake_ptr`没有重载`operator *`和`operator ->`，因此不能使用其访问指向对象，需要使用`lock()`方法从`wake_ptr`得到`shared_ptr`后才可以。
5. `scoped_arry`：功能和`scoped_ptr`相同，但是重载了`operator[]`函数，可以管理数组
6. `shared_arry`：功能和`shared_ptr`相同，但是重载了`operator[]`函数，可以管理数组

# 右值引用

1. 意义：C++11提出的右值引用的概念解决了C++的重大历史遗留问题，通过右值引用消除了标准库中的大量不必要的开销(容器等)同时为其他标准库提供了实现的可能。

## 右值引用

+ 作用：右值引用本身只是一种概念，是为了实现move和forward而创造出的新的产物。成为右值引用对象意味着该对象所持有的资源的所有权可以安全的被转移给其他对象，从而避免了拷贝、析构等操作。
+ 右值被绑定到右值引用后，其生命周期将捆绑到右值引用上，此时可以修改右值引用所引用的值。
+ 作为函数的参数，永远是一个左值，即使它(在函数的参数列表中)的类型是一个右值引用，因为函数调用时参数是需要被压栈的，这意味着参数一定有其地址。
+ **NOTE**：右值引用本身是一个左值，所以左值引用可以指向一个右值引用。

## 万能引用

+ 万能引用/通用引用：形如T&&**且**包含类型推导的引用形式可以被称为通用引用(如auto&&以及某些模板类/函数的参数)，否则就是右值引用。万能引用的实际引用方式取决于其被初始化时所使用的对象的引用类型。

1. 由于万能引用既能够绑定右值引用也可以绑定左值引用，所以可以被设计作为函数的参数，可以避免为不同的参数类型分别定义实现不同的重载函数。
2. 当应用1时到函数重载时又会造成问题，由于通用引用的类型推导可以匹配到大量的类型[重载时精确匹配优先与类型提升转换，由于这种贪婪性质，万能引用和重载结合会造成问题。

## 移动语义与完美转发

### move和forward

1. `move`和`forwaed`从语义上容易造成其一定执行了某种动作的错觉，其实`move`和`forwaed`是执行类型转换的函数模板，他们在运行时并不产生实际代码。
2. `move`本质上是一个无条件的将参数转换为右值的函数模板，或者说是`static_cast<T&&>()`的简单封装，只有被move操作的值类型本身支持`move`操作时才发生move，否则发生的任然是copy。
3. `forwaed`本质上是一个满足一定条件时才将参数转换为右值的函数模板。`forwaed`的使用需要两个参数(模板类型参数和函数参数)，只有函数参数是被右值初始化时，它才会将参数转换为右值，同时保留着该参数的左值性或右值性。
4. `move`和`forwaed`的使用规范：对右值引用使用`std::move`，对通用引用使用`std::forward`。

## 几种类型的绑定问题

|     值类型      |                  可绑定类型                  |
| :-------------: | :------------------------------------------: |
|  普通左值引用   |                   普通左值                   |
|  普通右值引用   |                   普通右值                   |
| `const`左值引用 | 普通左值、普通右值、`const`左值、`const`右值 |
| `const`右值引用 |            `const`右值、普通右值             |

## 关于返回值类型

+ 无论何时函数的返回值如果是局部对象，其类型不应该使用任何引用类型（右值引用也不行）。

+ 当返回值类型时，编译器默认会开启返回值优化RVO（避免拷贝）

### RVO

### 手动优化

1. 使用const引用`const Foo& foo = f()`

2. 使用右值引用`Foo&& foo = f()`，此时调用了移动构造函数

# 类型转换

## 传统类型转换

+ 即C风格的类型转换可能带来一些隐患，让一些问题难以察觉.
+ 在类模型中有时也会用到传统的类型转换方式，例如重载operator T函数实现类向类T的转换。

1. 隐式类型转换：由编译器自动完成，一般只作用到基本数据类型，将小内存的类型向大内存或相同内存大小的类型转换，但是其结果通常是不可预期的。
2. 显式/强制类型转换：显式要求编译器要转换的目标类型

## 标准类型转换

+ 优点：使用新的转换函数可以清楚的理解转换的具体含义，且支持一定程度的安全检查

1. `static_cast<type-id>(expression)`：用于有一定关系的指针/引用/对象以及基础数据之间。所谓关系在指针和引用上通常指继承关系[上转安全，下转危险]，在对象间通常按照先构造函数后类型转换运算符(`operator TYPE`)的顺序转换。
2. `const_cast<type-id>(expression)`：用于去除指针/引用的`const/volatile`限定符，转换前后数据的最终指向并不会改变。但并不意味着可以对原对象修改(取决于源对象的限定符)。
3. `reinterpret_cast<type-id>(expression)`：任意指针/引用类型之间、指针与大整数类型(与指针相同大小的比特位)、整数/枚举到指针之间的转换。该转换会产生一个和原值比特位一模一样的新值。
4. `dynamic_cast<type-id>(expression)`(有RTTI支持)：只接受基于类对象的指针和引用的类转换，且要求源和目标的类型具有继承关系。且该转换的实现依赖虚函数表。

## 建议

1. 只在数值类型（包括整型、浮点型、字符类型和枚举）上使用传统的转换方式(C式或函数式)。
2. 去const属性用`const_cast`。
3. 基本类型转换用`static_cast`。
4. 多态类之间的类型转换用`daynamic_cast`。
5. 不同类型的指针类型转换用`reinterpreter_cast`。

+ 总结`static_cast`和`reinterpret_cast`运算符要么直接被编译器拒绝进行转换，要么就一定会得到相应的目标类型的值。 而`dynamic_cast`却会进行判别，确定源指针所指的内容是否真的合适被目标指针接受。如果是否定的，那么`dynamic_cas`t则会返回null。这是通过检查"运行期类型信息"（Runtime type information，RTTI）来判定的，它还受到编译器的影响，有些编译器需要设置开启才能让程序正确运行。

## NOTE

1. `const_cast<>`不适用于迭代器的转换。因为其只是用于去掉类型前的限定符，而`const_iterator`和`iterator`是两个完全不同的类，其转换可以借助`void advance(，int distance())`的函数组合。

# 静态链接库和动态链接库

## GCC的工作流程

预处理(头文件展开、宏替换、去注释、条件编译等)->编译(检查语法生成汇编代码)->汇编(翻译为机器语言)->链接(决定库的载入方式)

## 静态库

1. 在链接阶段将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件。gcc加入-static参数即指定静态链接，使用ar程序创建静态库。
2. 优点：不依赖运行机器的库环境方便程序移植。
3. 缺点：文件大，修改需要重新全部打包，同一个库的代码在内存中可能有多份拷贝。

## 动态库

1. 程序运行过程中动态调用库文件，链接时仅仅在其中加入了所调用函数的描述信息。gcc默认为动态链接，-fPIC -shared控制生成静态库
2. 优点：可以增量更新，不浪费内存
3. 缺点：可移植性太差，严重依赖平台库环境

# STL容器

## 顺序容器(线性结构)

* array、vector、list、forward_list、deque

### vector

1. vector的理论存储上限可以调用max_size得到。

+ vector<bool>并不是一个STL容器，底层存储的并不是bool类型值，每个bool值都只使用一个比特位来存储。vector<bool>的operator[]返回的其实是一个代理对象，不满足容器要求的opertor[]返回指向元素的地址的要求。其本身是实验产物,注意在for循环中使用auto对vector<bool>遍历时,auto不会被推导为bool。

### deque

1. deque是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来，deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回。
2. deque由主控和存储区构成，通过主控维持整体连续的假象。所谓的主控是一小块连续的内存空间，其中每一个元素(此处成为一个结点)都是一个指向另一段称作缓冲区的连续性内存空间的指针，缓冲区才是deque的存储空间的主体。
3. deque的实现决定了其迭代器复杂度和vector不是一个量级，并不适合直接使用算法中需要随机迭代器支持的算法。

## 有序关联式容器(红黑树)

* set、multiset、map、multimap

+ 红黑树是一种平衡二叉搜索树

1. 迭代器：由于红黑树本身有序，因此其迭代器可以视作对树的一种便利方法。
2. 由于红黑树任何一个结点都是独立的，修改其中一个结点不会影响到其他的元素在内存中的位置，所以对于关联容器插入删除都不会导致任何迭代器失效，除了指向被删除元素的迭代器。
3. set与map的区别在于所使用的红黑树的节点的具体类型有所不同，map使用了pair结构。
4. 红黑树提供的`insert_unique`和`insert`提供了multi系列的支持。

## 无序关联式容器(哈希表)
* `unordered_set、unordered_multiset、unordered_map、unordered_multimap`

+ 上述四个容器的底层实现都依靠STL中的`hash_table`与`hase_table_node`结构，其中`hash_table`提供的`insert_unique`和`insert_equal`为multi系列依靠hash的容器提供了支持。

1. 标准库中哈希冲突的默认解决方法为链接法。
2. 哈希表中每个元素称为一个桶（bucket），每个被插入的元素利用哈希函数映射到对应的桶。为求得更好的性能，桶数量需要是质数，库通过打表加速质数的选择。为了能让桶数量动态增长，用vector作为桶的容器。
3. 所支持的都是前向迭代器，迭代器只支持operator++操作。

## 容器适配器：
* `stack、queue、priority_queue`

1. 容器适配器本质上还是容器，只是为了特定的使用功能将基础容器中的函数实现进行了组合、优化或者重写。
2. 容器适配器的底层容器并不是固定的，STL对`stack`和`queue`默认使用deque实现，`priority_queue`默认使用`vector`实现堆;

## 其它

1. assign与operator=：其基本作用都是为容器赋值，assign的使用更广一些。
2. at与operator[]：at提供边界检查，越界会抛出out_of_range异常。
3. array、vector、**deque**、string提供了随机访问迭代器支持的容器
4. map系列的容器支持按照key值删除元素
5. 算法的区间采用前开后闭的原因：可以统一空集的表示
6. list和forward_list容器都根据自身实现提供了sort成员函数来加速排序。
7. string的size和length没有本质区别，length是为了保持C风格而保留的老式函数。
8. erase方法返回了指向被删除元素的下一个元素的迭代器。
9. vector和deque支持shrink_to_fit()自动紧缩内存

## 堆

STL中并没有直接的数据结构实现了堆，但却在vector的结构上实现了堆的一系列操作。

1. 基于vector建堆：make_heap
2. 再对vector构成的堆变动之后的调整：push之后的push_heap，pop之后的pop_heap;
3. 对vector是否构成堆的判别操作：is_heap以及找到破坏堆的is_heap_until

## 迭代器支持及失效情况

+ [cppreference](https://zh.cppreference.com/w/cpp/container)底部提供了详细的各种容器的迭代器和引用在插入和操作后的失效情况说明,以及各容器支持的接口分布.

### 迭代器支持情况

|           不支持           |                             前向                             |               双向               |           随机            |
| :------------------------: | :----------------------------------------------------------: | :------------------------------: | :-----------------------: |
| stack,queue,priority_queue | forward_list,unordered_map,unordered_set,unordered_multimap,unordered_multiset | list,map,set,multi_map,multi_set | vector,string,array,deque |

### 迭代器及引用失效情况

1. 底层为数组的容器(`vector,string`)在插入删除点之后的失效(因为操作引起了存储转移),该点及之前的保持有效.
2. 底层为链表的容器 (`list,forward_list`)插入后均保持有效,删除后仅删除点失效.
3. 底层为红黑树 (`map,set,multimap,multiset`)插入后均有效,删除后除了删除点之外的均有效.
4. 底层为哈希表 ( `unordered_map,unordered_set,unordered_multimap,unordered_multiset`)在删除后除删除点之外均有效,插入后引用均合法,如果插入导致了重哈希则迭代器失效(少见).
5. `deque`在修改中部后迭代器和引用均失效,插入首尾失效,删除则仅操作点失效

# STL算法

## 查找算法(13个)：判断容器中是否包含某个值

1. adjacent_find：   在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的 ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。
2. binary_search： 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。
3. count：利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。
4. count_if：利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。
5. equal_range： 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。
6. find：   利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。
7. find_end：  在指定范围内查找"由输入的另外一对iterator标志的第二个序列"的最后一次出现。找到则返回最后一对的第一 个ForwardIterator，否则返回输入的"另外一对"的第一个ForwardIterator。重载版本使用用户输入的操作符代替等于操作。
8. find_first_of： 在指定范围内查找"由输入的另外一对iterator标志的第二个序列"中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。
9. find_if：使用输入的函数代替等于操作符执行find。
10. lower_bound：   返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。
11. upper_bound：  返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。
12. search：  给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。
13. search_n：  在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。

## 排序和通用算法(14个)：提供元素排序策略

1. inplace_merge：  合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。
2. merge：合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。
3. nth_element：  将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。
4. partial_sort：对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。
5. partial_sort_copy： 与partial_sort类似，不过将经过排序的序列复制到另一个容器。
6. partition： 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。
7. random_shuffle：对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。
8. reverse：  将指定范围内元素重新反序排序。
9. reverse_copy：与reverse类似，不过将结果写入另一个容器。
10. rotate： 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。
11. rotate_copy：   与rotate类似，不过将结果写入另一个容器。
12. sort： 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。
13. stable_sort：与sort类似，不过保留相等元素之间的顺序关系。
14. stable_partition：与partition类似，不过不保证保留容器中的相对顺序。

## 删除和替换算法(15个)

1. copy：复制序列
2. copy_backward： 与copy相同，不过元素是以相反顺序被拷贝。
3. iter_swap：   交换两个ForwardIterator的值。
4. remove：删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。
5. remove_copy： 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。
6. remove_if：   删除指定范围内输入操作结果为true的所有元素。
7. remove_copy_if： 将所有不匹配元素拷贝到一个指定容器。
8. replace：将指定范围内所有等于vold的元素都用vnew代替。
9. replace_copy： 与replace类似，不过将结果写入另一个容器。
10. replace_if：   将指定范围内所有操作结果为true的元素用新值代替。
11. replace_copy_if： 与replace_if，不过将结果写入另一个容器。
12. swap：   交换存储在两个对象中的值。
13. swap_range：将指定范围内的元素与另一个序列元素值进行交换。
14. unique：清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。
15. unique_copy：  与unique类似，不过把结果输出到另一个容器。

## 排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合

1. next_permutation： 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。
2. prev_permutation： 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用 自定义的比较操作。

## 算术算法(4个)

1. accumulate：iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。
2. partial_sum：创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。
3. inner_product：   对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。
4. adjacent_difference： 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。

## 生成和异变算法(6个)

1. fill： 将输入值赋给标志范围内的所有元素。
2. fill_n：将输入值赋给first到first+n范围内的所有元素。
3. for_each：  用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。
4. generate：  连续调用输入的函数来填充指定的范围。
5. generate_n： 与generate函数类似，填充从指定iterator开始的n个元素。
6. transform：将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。

## 关系算法(8个)

1. equal：  如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。
2. includes： 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的<操作符，成功返回true。重载版本使用用户输入的函数。>
3. lexicographical_compare： 比较两个序列。重载版本使用用户自定义比较操作。
4. max： 返回两个元素中较大一个。重载版本使用自定义比较操作。
5. max_element：  返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。
6. min：  返回两个元素中较小一个。重载版本使用自定义比较操作。
7. min_element：返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。
8. mismatch：并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。

## 集合算法(4个)

1. set_union：构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。
2. set_intersection： 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。
3. set_difference：构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用  自定义的比较操作。
4. set_symmetric_difference： 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。

## 堆算法(4个)

1. make_heap： 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。
2. pop_heap：   并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被"弹出"的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。
3. push_heap： 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。
4. sort_heap：  对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。

# STL仿函数与仿函数适配器

## 仿函数

1. 算术类仿函数(6个)：plus、minus、multiplier、divides、modulus、negate(取相反数)
2. 关系运算仿函数(6个)：less、less_equal、equal_to、not_equal_to、greater_equal、greater_equal_to
3. 逻辑运算仿函数(3个)：logical_and、logical_or、logical_no

## 函数适配器

+ 能够将仿函数和另一个仿函数（或某个值，或某一个函数）结合起来的仿函数。声明于<functional>中。
+ C++11/C++17/C++2x弃用了大量的函数适配器

# STL空间配置器

1. 出现背景：大量且频繁的小块内存非配带来了大量碎片，以及申请释放时的系统调用造成的性能损失。
2. 内存池：缓解小块内存分配带来的问题，基本的思想是一次向heap申请一块很大的内存(内存池)，如果申请小块内存的话就直接到内存池中去取。
3. 作用：完成内存配置与释放，对象构造和析构的工作。责任主体为allocator，其四大助手为allocate，deallocate，construct和destroy。
4. STL实现了std：：allocator(效率低，简单包装了new和delete，只为兼容老代码)和std：：alloc(实际使用的版本)

## 组成结构

1. 概述：一级空间配置器(大块(>128B)内存分配，封装了malloc与free)和二级空间配置器(重点，小块(<=128B)的在内存池分配)。

### 一级空间配置器

1. 首先尝试使用malloc分配内存
2. 如果空间不满足调用内存不足处理函数
3. 内存处理函数如果没有设置相应的处理函数，则抛出bad_alloc异常。否则循环调用处理函数直到成功。

+ **注意**："内存不足处理机制"是客户端的责任，设置"内存不足处理介质"也是客户端的责任。

### 二级空间配置器

1. 支持结构：堆内存池与free_list(16个链表首指针构成free_list数组，每个链表分别组织已从内存池分配的N×8B的空闲内存块(为了便于管理，在内存池上的分配以8B为基本单位))。

#### 分配策略

1. 首先尝试在free_list上寻找最小可满足内存块(其大小为n)，如果不满足调用refill从内存池申请
2. refill尝试从内存池分配max{1-20}个(STL默认一次申请多个)大小为n的内存块，如果得到满足，首先返回一个给上层调用，其余的挂到大小为n的free_list的元素的链表后面。
3. 如果第二步得不到满足(内存池可用小于n)，先将内存池中的剩余可用块挂到相应的free_list的相应节点链表后面，再向堆空间申请内存。
4. 如果第三步成功，再次执行第二步。否则在free_list寻找大于n的内存，有则将这一块内存归还到内存池，之后进行第二步，否则调用一级空间配置器。

## 缺点

1. 二级空间配置器造成的内碎片问题(尤其时频繁申请char这种小内存时)。
2. 二级空间配置器将空闲的内存一直自己持有没有回收给系统，可能造成堆存储不够或者二级配置器无法满足稍大一点的内存需求等问题。

# STL迭代器

1. 迭代器是一种抽象的设计概念，它提供一种方法，使之能够依序访问某个聚合物所含的各个元素，从而无需暴露该聚合物的内部表述方式。
2. 优化思想：利用C++重载机制和参数推导机制(traits，类型萃取)将运行期决议问题提前到编译期决议，实现了避免在运行时判断迭代器的类型。

## 类别

### 基本迭代器类型

+ 输入/出(i/ostream)、前(forward_list，unordered_<multi>[map|set])/双向(list，<multi>[map|set])、随机(vector，array，string，deque，内置指针数组)迭代器。

### 迭代器适配器

#### 插入适配器

1. 插入适配器inserter：要求容器有insert成员函数，如vector，list，map，set，deque(有点破坏deque数据结构)， inserter()可以快速创建该类型迭代器，参数中的位置参数仅做指示作用。
2. 前向插入适配器front_insert_iterator：要求类有push_front函数支持，如list和deque。可以借助front_inserter()快速创建。
3. 后向插入迭代器back_insert_iterator：要求成员函数push_back支持，如vector、list、deque。可以借助back_inserter()创建。

#### 逆向迭代器适配器

1. reverse_iterator：

#### 移动迭代器

1. move_inserter：C++11引入。可以实现以移动而非复制的方式，将某个区域空间中的元素移动至另一个指定的空间。

+ 调用make_move_iterator函数可以由基础迭代器快速创建move_iterator迭代器.

+ 此基础迭代器的类型虽然没有明确要求，但该模板类中某些成员方法的底层实现，需要此基础迭代器为双向迭代器或者随机访问迭代器。

+ 通过移动迭代器将容器中某区域的元素移动到了其他容器中，该区域内仍可能残留有之前存储的元素，但这些元素是不能再被使用的，否则极有可能使程序产生各种其他错误。

  |                         迭代器适配器                         |                           创建函数                           |    要求    |
  | :----------------------------------------------------------: | :----------------------------------------------------------: | :--------: |
  | [reverse_iterator](https://zh.cppreference.com/w/cpp/iterator/reverse_iterator) | [make_reverse_iterator](https://zh.cppreference.com/w/cpp/iterator/make_reverse_iterator) |            |
  | [move_iterator](https://zh.cppreference.com/w/cpp/iterator/move_iterator) | [make_move_iterator](https://zh.cppreference.com/w/cpp/iterator/make_move_iterator) |            |
  | [back_insert_iterator](https://zh.cppreference.com/w/cpp/iterator/back_insert_iterator) | [back_inserter](https://zh.cppreference.com/w/cpp/iterator/back_inserter) | push\_back |
  | [front_insert_iterator](https://zh.cppreference.com/w/cpp/iterator/front_insert_iterator) | [front_inserter](https://zh.cppreference.com/w/cpp/iterator/front_inserter) | push_front |
  | [insert_iterator](https://zh.cppreference.com/w/cpp/iterator/insert_iterator) | [inserter](https://zh.cppreference.com/w/cpp/iterator/inserter) |   insert   |

## 迭代器的移动

1. advance：参数本身被改变，迭代器至少为单向迭代器，当步数参数小于0则必须是双向迭代器。
2. prev：不改变参数。获取一个距离指定迭代器 n 个元素的迭代器。要求为双向或者随机迭代器。**自身不会检验新迭代器的指向是否合理**
3. next：不改变参数。迭代器类型要求同1，单向迭代器只能用正参数。**也不会检查新迭代器指向的有效性**。

## 指针、引用和迭代器

+ 引用的本质在大多数时候是一个被施加了许多限制的指针(在面对右值可以延长其生命器)，通过这些语法上的限制规避了使用裸指针时的一些危险性为，其效率和裸指针相同。
+ 迭代器是模仿指针的行为设计的类模板，是对指针概念的一种提升。指针也可以被视为一种迭代器。迭代器更像是一组抽象的接口，满足了这一组接口就可以称之为迭代器，满足这些接口的具体实现方法高度依赖于实际的数据结构。

# STL正则表达式

+ 字符串处理的利器

## 构成

### 正则表达式regex

+ 正则表达式的核心，表达式极大的影响了最终的效率
+ 支持文法：STL的regex库默认支持ECMAScript文法，此外也提供了grep、egrep、awk等文法的支持。其文法大同小异，在这里不做具体展开。

1. [正则表达式30分钟入门教程](https://deerchao.cn/tutorials/regex/regex.htm)
2. [C++正则知识](https://github.com/HesseSummer/cspSolution/blob/master/C%2B%2B%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99.md)
3. [learn-regex](https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md)
4. [常用正则表达式](https://github.com/cdoco/common-regex/blob/master/README.md)

### 搜索匹配算法

1. `regex_match()`:会在目标字符串中尝试完全匹配正则表达式。
2. `regex_search()`:在目标字符串中搜索匹配正则表达式的部分,查找结果包含了匹配的子串和子串在目标字符串中的起始和结束地址。
3. `regex_replace()`:查找符合正则表达式的子串并替换。
4. `sregex_iterator()`:迭代器适配器，调用`regex_search`来遍历一个string中所有匹配的子串

### 结果匹配集

1. smatch/cmatch:以`string/const char*`格式保存匹配集合

## 实例

1. [C++与正则表达式](https://paul.pub/cpp-regex/)

# CPP IO处理

+ C++包含两个输入/输出库：现代的、基于流的I/O库和C风格I/O函数的标准集合。
+ 基于流的IO围绕抽象的输入/输出设备。通过这些抽象可以以相同的代码来处理面向文件、内存流或其他自定义的适配器设备执行IO操作。
+ 每个C流与外部物理设备（文件、标准输入流、打印机、序列端口等）关联，只能通过`std::FILE*`类型指针访问及操作

## 基本流对象

![流对象继承关系](img/lang/io.svg)

|                             类                              |                       作用                        |
| :---------------------------------------------------------: | :-----------------------------------------------: |
| [ios_base](https://zh.cppreference.com/w/cpp/io/ios_base)  |    状态信息、控制信息、内部存储、回调、异常等     |
| [basic_ios](https://zh.cppreference.com/w/cpp/io/basic_ios) | 提供了std::basic_streambuf 的接口，管理任意流缓冲 |

+ cin、cout、cerr、clog都是预先已经定义的全局对象

### 文件流

|    操作标志    |                  操作方式                  |
| :------------: | :----------------------------------------: |
|  ios::in/out   |       为输入(读)/输出(写)而打开文件        |
|  ios::binary   |       用于二进制文件的二进制方式打开       |
|    ios::ate    |              初始位置：文件尾              |
|    ios::app    |           所有输出附加在文件末尾           |
|   ios::trunc   |        如果文件已存在则先删除该文件        |
| ios::nocreate  |    不建立文件，所以文件不存在时打开失败    |
| ios::noreplace | 不覆盖文件，所以打开文件时如果文件存在失败 |

|    0     |    1     |    2     |    3     |
| :------: | :------: | :------: | :------: |
| 普通文件 | 只读文件 | 隐藏文件 | 系统文件 |

|       操作符        |           格式           |    场景    |
| :-----------------: | :----------------------: | :--------: |
|     dec/hex/oct     | 格式化为十、十六、八进制 | 输入和输出 |
| setpxecision(int p) |   设置浮点数的精度位数   |    输出    |

| 状态标记位常量 |                         含义                         | good() | eof() | fail() | bad() |
| :------------: | :--------------------------------------------------: | :----: | :---: | :----: | :---: |
|  ios::goodbit  |                       没有错误                       |   1    |   0   |   0    |   0   |
|  ios::eofbit   |                     已到达文件尾                     |   0    |   1   |   0    |   0   |
|  ios::failbit  | 非致命可挽回的逻辑错误(如读数字遇到字母)，可继续使用 |   0    |   0   |   1    |   0   |
|  ios::badbit   |   致命性不可挽回的物理错误(如物理上)，不可继续使用   |   0    |   0   |   1    |   1   |

#### 流指针

+ 所有输入/输出流对象都有至少一个流指针，该指针在输入流对象中指向下一个将被读取的元素，在输出流对象中指向写入下一个元素的位置。

+ 获取流指针：tellg(void)或 tellp(void)返回pos_type 类型的值(int)代表当前get 流指针的位置或 put 流指针的位置。

+ 改变流指针：seekg() 或seekp()可以以绝对(从文件开始计算)或者相对的方式改变流指针get 和put的位置。

  + |  ios::beg  |    ios::cur    | ios::end |
    | :--------: | :------------: | :------: |
    | 流开始位置 | 流指针当前位置 |  流末尾  |
+ **NOTE:**对文本和二进制文件流指针的计算方法是不同的。由于文本模式的文件中某些特殊字符可能被修改，建议对以文本模式打开的文件总是使用seekg和seekp的绝对位置版本，而且不要对tellg 或 tellp 的返回值进行修改。对二进制文件可以任意使用这些函数，应该不会有任何意外的行为产生。

#### 行结束标志

+ 换到下一行开始这样一个控制命令在windows和linux系统下的控制方法不同。在windows下为\r\n，在linux为\n。(\r为回车，\n为换行)

## 缓冲

+ 重要机制：每个标准C++输入输出流对象都包含一个指向streambuf的指针，basic_ios允许多个流对象绑定同一个缓冲区对象streambuf（流和 I/O 设备之间加入的抽象中间层，一旦流对象绑定的缓冲区对象发生变化，最终的 I/O 效果也会随之发生变化）。

### 缓冲区

+ 如果未显示绑定缓冲区(通过setvbuf()和 setbuf())，系统会默认为标准输入输出设置一个缓冲区(大小由宏BUFSIZ定义,与系统相关,win=512B,linux=1024B)。
+ setbuf()都将缓冲区设置的大小为BUFSIZ；setvbuf设置缓冲区大小以及缓冲区的模式（行缓冲、全缓冲、无缓冲）。
+ **NOTE**：上述两个函数设置的是**C的输入输出缓冲区**，因为c++和c的缓冲区默认是同步的，所有该函数会对c++有影响。
+ 缓冲刷新/同步
  1. 时机：缓冲满、**行缓冲区**遇回车、其他直接或间接调用flush的函数、调用无参版本函数sync()、进程结束(流关闭、文件关闭)
  2. 动作：输出缓冲区的刷新动作一般导致缓冲区内的内容被执行IO到其关联的文件描述符中，然后清空缓冲区。而对于输入缓冲区，不可能强制实现将输入缓冲区强制注入到关联的实体中，因为输入是不可预测掌控的，所以对输入缓冲区的刷新表现为清空缓冲区里的当前内容，等待输入进入输入缓冲区。
| 缓冲类型 |                      特点                       |    典型代表    |
| :------: | :---------------------------------------------: | :------------: |
|  行缓冲  | 当缓冲区内容遇到**换行**时，即进行实际的I/O操作 |  读写磁盘文件  |
|  全缓冲  |      填满标准I/O缓冲区才进行实际的I/O操作       | 标准输入和输出 |
|  无缓冲  |                   直接I/O操作                   |    标准错误    |

| 缓冲操作函数 |                      作用                      |
| :----------: | :--------------------------------------------: |
|     endl     |         添加换行line、输出、刷新缓冲区         |
|     ends     |     添加空格space、输出。**不刷新缓冲区**      |
|    flush     |                输出、刷新缓冲区                |
|   **sync**   | 刷新**输入**缓冲区(清除输入缓冲区)或输出缓冲区 |
|   unitbuf    |      启用**输出流**在任何操作后都自动刷新      |
|  ununitbuf   |      禁用**输出流**在任何操作后的自动刷新      |

### 应用

#### IO加速

+ 通过调用成员函数rdbuf()获取指针,直接访问底层streambuf对象，进行数据的直接读写，跳过上层的格式化输入输出操作，提高了读写效率。对于文件流、字符串流类，都可以使用

#### 流同步

+ iostream和cstdio默认共用一套标准输入、输出缓冲区，因此可以在程序中混用配对的流对，其效果是相同的。
+ 流同步导致所以cin、cout比scanf、printf速度要慢(维护兼容性的开销)，可以用std::ios_base::sync_with_stdio(false)来取消这种同步，取消后配对的流对的输出顺序可能和混用的逻辑顺序不同。

#### 流关联

+ C++ 标准库为IO流提供了一个成员函数tie可以把 一个istream 对象关联到一个ostream，也可以把 一个ostream 关联到另一个 ostream。

1. 标准库默认把cin和cout关联在一起，cin 会刷新cout的缓冲区，可以用函数cin.tie(nullptr)来解除关联。
2. 实现流底层的streambuf在不同流之间的关联绑定

 ```cpp
    std::ifstream fin{"oj.test.txt"};
    auto cin_buf = std::cin.rdbuf(fin.rdbuf()); //返回关联前的缓冲区，绑定fin的缓冲到cin
    std::cin.tie(nullptr);      //解除cin和cout的缓冲区绑定
    std::string temp;
    std::getline(std::cin, temp);

 ```

### 影响

#### \n与缓冲刷新

+ 无缓冲的输出流(如cerr)：endl与\n完全一致。
+ 带缓冲的输出流(clog等)：
  + endl除了输出换行之外，还刷新输出流或错误流缓冲区。
  + \n导致的行为在标准输出和非标准输出表现并不一致(在manjaro linux5.10 gcc10.2下验证)
    1. 非标准输出，\n只会输出带换行的内容，并不会去刷新流。
    2. **多数实现中**标准输出是行缓冲的，除非执行`std::ios::sync_with_stdio(false)`否则'\n'会导致缓冲刷新。[来源](https://zh.cppreference.com/w/cpp/io/manip/endl)

#### 诡异的std::cin

+ 根本原因:cin背后是一个行缓冲，从里面取走数据之后并没有取走全部数据(留下了标志、换行符等)而且也没有刷新缓冲，造成缓冲不干净而影响下一次读取缓冲。
+ 标准输入流的“文件末尾”：win下ctrl+z表示输入结束，linux下ctrl+d表示输入结束

|       方法       |                作用                 |
| :--------------: | :---------------------------------: |
|   cin.clear()    |     清空流中的标志(EOF、错误等)     |
| cin.ingore(a,ch) | 忽略流中的字符第一个ch或a个任意字符 |
|    cin.sync()    |         清除缓存区的数据流          |

## 流相关迭代器

+ 存在流迭代器和支持流迭代器的流缓冲迭代器。
+ 通过流缓冲迭代器用户可以跨过iostream，直接跟流缓冲区打交道。
+ 流缓冲区迭代器仅会将元素**以字符的形式（`char、wchar_t、char16_t、char32_t`）**读或者写到流缓冲区中，由于不会涉及数据类型的转换，读写数据的速度比流迭代器要快。

### 输入流迭代器istream_iterator

+ `istream_iterator<T,CharT=char>(istream)`在**文本模式(char、wchar等，不支持二进制)**下从istream流中提取数据。
+ 要求T类型是基本数据类型或者实现了将输出流写入T中的operator >>()方法。
+ **NOTE**:
    1. 默认跳过空白字符(除非明确禁止)
    2. 当多个输入流迭代器指向同一个输入流时，其中一个迭代器位置的改变也会使另一个迭代器的位置改变(他们相当于共享了一个底层结构)

### 输出流迭代器ostream_iterator

+ `ostream_iterator<T, CharT=char>(ostream <,const CharT* delim>)`:以`CharT`的形式`(char、wchar)`将若干个T写入到输出流`ostream`，每写一个T对象追加一个`delim`。
+ 要求T类型是实现了将T对象写入流中的`operator <<()`方法数据结构或者普通数据类型。
+ 其`operator *()、++()、++(int)`方法始终返回当前指向的对象，不包含其他任何操作。这些函数的存在只是为了满足迭代器的规范。
+ **NOTE:**
    1. 输出流迭代器的输出更新本质上最终都是通过operator =()函数实现。

### 输出流缓冲迭代器ostreambuf_iterator

### 输入流缓冲迭代器istreambuf_iterator

# 类型推导

## auto

+ 背景：auto作为变量存储关键字长期以来并没有发挥大的作用，C++11决定用auto依据初始值实现编译期的类型推导
+ note：auto仅仅是一个占位符，在编译期间会自动推导出变量的类型，C++中的变量依然有明确的类型。
+ note：auto表达式推导出的类型和auto被替换时的类型不同，被替换成的字符只是最终类型的一部分。

### 用法

+ 由于auto用来做类型推导，所以auto类型的变量必须在声明的时候进行初始化。

1. 当一个auto修饰多个变量时，变量推导出的类型不能有冲突。
2. auto与*和&混用：此时auto被推导为不带指针或引用的类型，但是auto声明的变量的类型为auto+cv限定符。
3. 当auto的=右边的表达式是一个引用类型时，auto 会把引用抛弃，直接推导出它的原始类型。
4. auto与const的结合：当左边的类型声明含有引用或者指针符号时，推导出的最终类型含有const属性，否则const被去除。

### 限制

1. 不能做函数参数(C++11不允许;C++14已经允许，但是在设置默认参数可能无法匹配)
2. 不能作用于类的非静态成员变量(类的静态成员变量似乎也不行，没实验成功)。？？？？？？？？？？？？？？？？？？
3. 不能用于定义数组，即不能是auto var[]的形式。
4. 不能作用于模板参数，但在泛型编程中可以得到大量应用。

## decltype

+ 背景：C++11新增，根据表达式(必须有类型)参数完成编译期的类型推导。

### decltype(exp)推导规则

1. 如果exp是一个不被括号( )包围的表达式，或者是一个类成员访问表达式，或者是一个**单独的**变量，那么decltype(exp)的类型就和exp一致。
2. 如果exp是函数调用(形式要满足函数调用，但是不会被执行)，那么`decltype(exp)`的类型就和函数返回值的类型一致。
3. 如果exp是一个左值表达式(注意与1中的单独的变量区分)，或者被括号( )包围，那么`decltype(exp)`的类型就是exp的引用。

## auto与decltype的不同

### 对cv限定符(const、volatile)的处理

+ decltype：保留cv限定符
+ auto：如果表达式的类型是指针或者引用，保留cv限定符，否则丢弃限定符。

### 对引用的处理

1. decltype 会保留引用类型.
2. auto会抛弃引用类型，直接推导出它的原始类型。

### 总结

+ auto书写简单、推导复杂(有时会改变原始类型)。decltype书写复杂、推导简单

## traits(类型萃取)

+ 提出背景：

 1. template参数推导：无法用于函数返回类型
 2. 内嵌声明型别：无法处理原生指针

+ 思想：加入中间层，提供一个统一的接口，通过这个接口可以获取对象/数据的类型，其他的容器实现这一接口

### 迭代器相关的类型萃取

1. value_type： 代表迭代器所指对象的类型。
2. difference_type：代表两个迭代器之间的距离
3. reference_type：代表迭代器所指对象的引用类型。简言之，它是operator*()的返回类型
4. pointer_type：代表迭代器所致对象的指针类型。简言之，它是operator->()的返回类型
5. iterator_category：代表1中提出的五种迭代器的类型标识

### 在迭代器中的应用和实现

1. 原生指针：利用模板类的偏特化，为原生的指针和const指针提供iterator_traits。
2. 一般迭代器：在数据结构中的实现里，统一提供一个接口来标明自己的数据类型来供外部访问。

# lambda表达式/闭包

+ 形式：`[capture] <(parameters) mutable noexcpt/throw() -> return_type> { body }`，尖括号内可选，但param和mutable以及异常管理中的任意多个必须同时出现。
+ 本质：函数对象，内部创建了一个重载()操作符的类。
+ 大致原理：在C++中，lambda表达式是函数对象的语法糖，每当定义一个lambda表达式，编译器会自动生成一个匿名类（重载了()运算符），也称为闭包类型（closure type）。在运行时，lambda表达式就会返回一个匿名的闭包实例。

## 形式说明

### 捕获变量列表

1. [<[ ，=，&][var]>]：<>内前半部分的三个符号可以与var随意结合/不结合用来表示捕获变量的方式。为空则不捕获任何变量，=表示值捕获，&为引用捕获，与var结合表示对该变量使用结合的捕获方式，不结合表示捕获在表达式内部被用到的全部变量，单独var表示值捕获。通用的捕获在捕获列表前部，特殊捕获在后，以逗号分割。
2. 变量来源：使用那些**到定义Lambda为止时**Lambda所在作用范围内可见的局部变量(包括Lambda所在类的this)。非局部变量，如静态变量、全局变量等可以不经捕获，直接使用；
3. 捕获时机：lambda被声明时而非运行时，对于引用则是运行时在访问外部。
4. 捕获this：只有包含且最靠近lambda表达式的函数不是静态成员函数时才能被捕获this。在C++17之前只能通过引[this]以引用捕获当前对象（其实是复制指针），c++17以后可以通过[*this]进行值捕获。捕获之后lambda 表达式拥有和当前类成员函数同样的访问权限、控制权限和访问方式。

#### 其他说明

1. note：如果一个闭包含有局部变量的引用，在超出创建它的作用域之外的地方被使用的话，这种行为是未定义的!
2. 捕捉列表不允许变量重复传递

### parameters

1. 不支持默认参数、不支持可变参数、不支持匿名参数。

### multable

1. 背景：对于值捕捉方式，类会相应添加对应类型的非静态数据成员，在运行时会用复制的值初始化这些成员变量，从对于引用捕获的变量，标准中没有规定其在类中的表示方法。
2. 重载的operator()方法默认是const限定的，无法修改值传递后构建的成员。而对于引用的传递方式，并不会改变引用本身，而只会改变引用的值，因此就可以改变。
3. 作用：mutable关键字可以使重载的operator()函数丢弃函数声明末尾的const限定符，从而修改传递进来的拷贝。

### noexcept/throw()

+ `noexcept`表示不抛出遗产，throw表示只抛出指定类型的异常。

### return\_type

+ 当返回值为 void，或者函数体中只有一处return(此时编译器可以自动推断出返回值类型)时，这部分可以省略。

## 其它

1. lambda禁用了赋值操作符，但是可以使用拷贝构造函数(可以用已有的lambda表达式初始化新的lambda表达式)。
2. lambda可以赋值给具有相同形式的函数指针
3. 如果lambda的生存期长于捕获的对象，则可能导致悬空引用的问题。
4. 利用lambda的立即调用实现的[magic](https：//lesleylai.info/zh/c++-lambda/)，推荐这位[博主](https：//lesleylai.info/zh)
5. 没有捕获变量的lambda表达式可以直接转换为函数指针，而捕获变量的lambda表达式则不能转换为函数指针。

## [CPP14 lambda表达式增强](#lambda表达式)

# 类相关

## 权限控制

### 外部访问控制

+ Public，Protected，Private控制本类、子类、外部调用对类中成员的访问权限，访问控制逐渐严格(protect屏蔽外部访问，private只有本类可见)。

### 特殊权限控制

+ 概述：为了满足某些特殊的需求，可能对The Big Three等特殊的基础函数的权限加以约束(protect或者private)，此时程序中对这些函数的显式或隐式调用将会被编译器阻止。而对这些函数的访问是不可或缺的，为了访问这些函数完成对象的创建和销毁，必须借用类的内部成员间接调用这些函数并返回信息。

+ 访问方法

1. 借助类的static成员(函数或者数据成员)属于类但却独立于类存在的特性，利用公有的static成员间接调用
2. 借助类的友元函数或者友元类，利用友元成员(友元可以无视一切权限控制)间接调用

#### 构造函数private化

##### 影响

1. 禁止该类被继承：利用子类的构造函数必须首先调用基类的构造函数，这种外部调用要求基类的构造函数必须是**public或者protect**的访问控制权限

2. 在间接调用构造函数返回对象时不能使用值传递(需要调用构造函数创建临时对象)，所以**只能以指针或者引用**的方式返回对象和传递参数，此时的对象**既可以创建在堆上也可以在栈上**。

#### 构造函数protect化

##### 影响

1. 和构造函数private化相比，这种限制下类可以被继承(protect限定的成员可以被子类直接访问)。

#### 析构函数private化

##### 影响

1. 只能在堆上创建对象，这是因为在栈上创建对象是由编译器自动生成的代码，此时编译器会检查对象的构造和析构函数是否可以被外部调用。

+ 如果构造函数不允许被外部调用，编译器将会拒绝为其自动生成对象(参考上面的解决办法)。
+ 如果析构函数不允许被外部调用，即使通过其他方法调用构造函数在栈上创建了对象，编译器在尝试直接或间接调用析构函数函数时任然会失败，此时编译器也会拒绝在栈上创建对象(因为无法完成自动回收)。

## 初始化方法

+ 初始化列表发生在就地初始化之后，即最终的初始化结果以初始化列表为准。

### 初始化列表

1. 必用情况：const成员或引用类型的成员、成员类型是没有默认构造函数的类。
2. 好处：C++在进入构造函数的函数体之前已经完成对类数据成员的构造。使用初始化列表可以一步构建出成员，而函数体内的赋值初始化进行的是对已经构造好的类对象的赋值，又调用个拷贝赋值操作符才能完成。
3. 初始化顺序：按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序。

### 就地初始化

+ 定义类时给变量赋初始值，C++11前只能对结构体或类的静态常量成员进行就地初始化。

```cpp
class Info{
 private:
  int _type {0};
  char _a = 'a';
  std::string x = "hello world"; //可以
};
```

### 列表初始化list\_initialization

+ 作用：提供了统一的初始化方式，使过去适用于POD类型的列表初始化得以应用到其它通用类型的初始化上。同时也适用于使用new操作等初始化方式。
+ 适用范围：聚合体类型和POD类型，尤其是违反聚合体规定1的列表初始化在编译时不会报错，但是实际上赋值的是一个随机值，会造成难以发现的Bug。
+ 可以通过自定义类型的构造函数来使非聚合体类型的类型支持列表初始化。
+ 额外收益：该机制可以**防止类型收窄**，避免一些隐式的类型转换。

#### 聚合体

1. 无用户自定义构造函数
2. 无基类、虚函数
3. 无私有或者受保护的非静态数据成员
4. 无{}和=直接初始化的非静态数据成员。

#### std::initializer\_list

+ std提供的一个轻量化的类模板容器，可以接受任意长度的同类型的数据，该容器实现了迭代器等容器的一般接口(迭代器、begin、end、size)。
+ 注意事项

1. 接受的可变参数中的参数必须是同类型或者是可以转换为显式指定过的类型。
2. 只能被整体的初始化和复制，迭代器访问到的数据都是不可更改的。
3. 其保存的值是对数据来源的引用，要注意列表初始化时使用的数据源的生命周期。

### 委托构造函数

+ 把构造的任务委派给目标构造函数来完成类的构造，避免多个构造函数执行类似操作的代码量（编译器原则上不允许在构造函数中调用任何构造函数，即`this->Info()`的编译会被阻止。

+ 语法规则：在构造函数的初始化列表中显式调用被委托的构造函数。

+ **NOTE**

1. 不能在委托构造函数的初始化列表中初始化其他数据成员，即**不能同时使用初始化列表和委托构造函数**
2. 委托构造函数的函数体中的操作在最后执行
3. 该机制下可能构成委托链或者委托环，编译器不能检查委托环的出现（会导致递归栈爆栈）
4. 目标/被委托的构造函数可以是private的构造函数

#### 异常处理

+ 如果在委派构造函数中使用try的话，那么从目标构造函数中产生的异常，都可以在委派构造函数中被捕捉到。

+ ```cpp
  class DCExcept {
  public:
    DCExcept(double d)
        try : DCExcept(1, d) {
            cout << "Run the body." << endl;
            // 其他初始化操作
        }catch(...) {
            cout << "caught exception." << endl;
            // 异常处理
        }
  private:
    DCExcept(int i, double d){
        cout << "going to throw!" << endl;
        throw 0;//抛出异常
    }
    int type;
    double data;
  };
  int main() {
    DCExcept a(1.2);
  }
  /*输出:
  going to throw!
  caught exception.
  terminate called after throwing an instance of 'int'
  Aborted*/
  ```

## 函数

### The Big Three

+ 拷贝构造函数、拷贝赋值函数、析构函数一起构成C++三大函数

1. 申明时初始化、参数的值传递、以值返回时调用拷贝构造函数，当用户没有自定义拷贝构造函数时，编译器会提供一个默认的执行浅拷贝/位拷贝的拷贝构造函数(合成的拷贝构造函数)。
2. 赋值/赋值构造函数应用于两个已经构造的对象，为了提高赋值时的异常安全性，赋值操作应当遵守copy/move and swap的实现原则。

### 编译器自动生成的函数(4+2)

#### 生成内容

+ 4(构造函数、[拷贝构造函数、拷贝赋值函数/运算符、析构函数](#The Big Three)) + 2(c++11新增：移动构造函数、移动赋值函数)，一共6个`public`的`inline`函数

#### 生成规则

+ 只有在被需要且用户未提供自定义版本的时候才会生成，例如C++不会为一个未使用的空类生成构造函数

1. 默认构造函数：只在用户没有定义其它任何类型的构造函数时才会生成，概括来讲有四种情况[参考来源](https://cloud.tencent.com/developer/article/1036240)：
   1. B类含A**类成员对象，且该类有默认构造函数**：因为此时 编译器并不知道A类默认构造函数做了什么，出于消除A类的不当操作的原因，编译器将为B类生成构造函数
   2. 类的**基类提供了默认的构造函数**。
   3. 类内定义了**虚函数**
   4. 类使用了**虚继承**

| 自动生成构造函数时机 | 原因 |
| :------------------: | :--: |
|                      |      |
|                      |      |
|                      |      |
|                      |      |

2. 拷贝构造函数：只有用户没有定义 **移动构造函数**(5) 和 **移动赋值运算符**(6) 时，才会生成

3. 拷贝赋值运算符：只有用户没有定义 **移动构造函数**(5) 和 **移动赋值运算符**(6) 时，才会生成

4. 析构函数：用户没有定义析构函数

5. 移动构造函数：只有用户没有定义 **拷贝构造函数**(2), **拷贝赋值运算符**(3), **析构函数**(4) 和 **移动赋值运算符**(6) 时，才会生成

6. 移动赋值运算符：只有用户没有定义 **拷贝构造函数**(2), **拷贝赋值运算符**(3), **析构函数**(4) 和 **移动构造函数**(5) 时，才会生成

#### 函数生成管理

##### 使用缺省函数=default

在默认函数定义或声明时加上`=default`，来让编译器生成该函数的默认版本。

##### 禁止函数=delete

+ 在C++98中，可以把该函数设为私有，不定义，这样，如果有人调用就会报错。

+ 在c++11中，任何函数都可以被禁止(包括非成员函数、模板函数的具化实现、默认生成的成员函数)

```cpp
  bool isLucky(int number) = delete;
  bool isLucky(float) = delete;      //阻止int->float的隐式转换
  
  template<typename T> void ProcessPointer(T* ptr);
  template<> void ProcessPointer(void*) = delete; //阻止void*具化
  template<> void ProcessPointer(char*) = delete; //阻止char*具化
```

##### 禁止构造函数类型转换explicit

1. 背景：在类的构造函数只传递**一个有效参数(单参或者多参时后面都有默认参数)时**，C++在编译时会默认将该构造函数参数类型的数据转换为该类对象。
2.explicit可以阻止构造函数的这种转换，避免一些难以发现的错误。

### 自增/减运算符重载

+ 后缀形式的自增/减重载接受一个无用的int 形参来与前缀形式区分

### inline函数
+ 普通的inline函数没有函数地址，在编译时只是将代码展开替换

## friend成员

+ 设计目的：提供给友元访问自己私有和保护成员的一种机制。
+ 表现形式：友元类、友元函数。
+ note：友元关系不具有继承性和传递性。

## 继承

### 虚函数

| 不可virtual |                             原因                             |
| :---------: | :----------------------------------------------------------: |
| inline函数  |                      inline函数没有地址                      |
| static函数  |                    static函数没有this指针                    |
|  构造函数   | 对象中的虚函数表指针和虚函数表在构造函数的初始化列表阶段(编译期)初始化 |

### 限制继承final

+ 使用方法：将final关键字添加到定义类时的类的名称的后面
+ 影响：该类不能被继承

### 继承下的访问控制

+ 子类对父类的访问控制权限由父类控制，三种继承方式不影响子类对父类的访问权限。
+ 继承方式是为了控制子类的调用方对父类的访问，三种继承相当于将父类的public和protect成员访问权限变为继承方式所标明的权限。父类的Private成员在子类中始终不可见

| 父类成员\继承方式 |   Public   |  Protect   |  Private   |
| :---------------: | :--------: | :--------: | :--------: |
|      Public       |   Public   |  Protect   |  Private   |
|      Protect      |  Protect   |  Protect   |  Private   |
|      Private      | **不可见** | **不可见** | **不可见** |

### 继承的内容

|           父类           |       子类       |                    原因/使用方法                    |
| :----------------------: | :--------------: | :-------------------------------------------------: |
|     所有普通数据成员     |       继承       |                受访问控制的直接使用                 |
|         所有接口         |       继承       |                受访问控制的直接使用                 |
|       静态数据成员       | **不继承但可用** |   基类及所有子类共用基类的同一个静态数据成员空间    |
|       静态函数成员       | **不继承但可用** |    static函数实际上是“加上了访问控制的全局函数”     |
|       友元函数/类        |      不继承      |                   重写入类的友元                    |
|      普通运算符重载      |       继承       |                受访问控制的直接使用                 |
| =重载：拷贝/移动赋值函数 | **不继承但可用** |          `using BaseClassName::operator=;`          |
|         成员函数         | **不继承但可用** | `using BaseClassName::function_name;`，可以避免隐藏 |
|       所有构造函数       | **不继承但可用** |        `using BaseClassName::BaseClassName;`        |
|         析构函数         | **不继承但可用** |                   析构时自动调用                    |

```cpp
class Base{
    static int global;
public:
    Base& operator=(int a){cout << "Base::" << __FUNCTION__ << endl; return *this;}
    Base& operator+(int a){cout << "Base::" << __FUNCTION__ << endl; return *this;}
    Base& common_function(int a){cout << "Base::" << __FUNCTION__ << endl; return *this;}
    static void static_function(){cout << "Global::" << __FUNCTION__ << "> <global=" << global << endl;}
};

class Derive : public Base{
    public:
        using Base::operator=;
        using Base::common_function;
        Derive& common_function(double a){cout << "Derive::" << __FUNCTION__ << endl; return *this;}
};

int Base::global = 12;

int main(){
    Derive derive;
    derive.common_function(0.1).common_function(0);
    derive.operator+(1);
    derive.operator=(2);
    Derive::static_function();
    Base::static_function();
    return 0;
}
/*输出
Derive::common_function
Base::common_function
Base::operator+
Base::operator=
Globalstatic_function> <global=12
Globalstatic_function> <global=12
*/
```

##### 继承除赋值运算符重载

+ C++的类会默认生成自己的拷贝赋值函数(`operator =()`)，此时父类的拷贝赋值运算符就被覆盖隐藏了，此时父类的拷贝赋值函数也就不被继承。

##### [继承构造函数](https://www.cnblogs.com/5iedu/p/11291124.html)

1. 一旦使用using来声明继承基类的构造函数，编译器就**不再为派生类生成默认构造函数**。
2. 继承构造函数只会初始化基类中的成员变量，对于派生类中的成员变量则需由派生类自行初始化（如“就地初始化”、初始化列表等）
3. 对于继承构造函数来说，參数的默认值是不会被继承的????。并且基类构造函数的默认值会导致基类产生多个构造函数版本号（即从默认參数开始前面减默认参数，直到包括无默认参数的构造函数），这些函数版本号都会被派生类继承。
4. 当派生类拥有多个基类时，多个基类中的同参的构造函数会导致派生类中的继承构造函数的函数名冲突。对此可以再派生类中显式申明自己构造函数，其参数和基类间冲突的构造函数的参数相同。
5. 如果基类的构造函数被声明为**私有构造函数**或者派生类是从基类**虚继承**的，那么就不能在派生类中声明继承构造函数。
6. C++11中继承构造函数与派生类的各种类默认函数一样，是隐式声明的。即如果一个继承构造函数不被相关代码使用，编译器不会为其产生真正的函数代码。这比显式声明函数更加节省目标代码空间。

```cpp
#include <iostream>
using namespace std;

class Base1
{
public:
//   Base1() { cout << "Base1::" << __FUNCTION__ << " void " << endl; }
    explicit Base1(char first) { cout << "Base1::" << __FUNCTION__ << " char " <<endl; }
    explicit Base1(char* first, double second = 2.0, double third = 3.0, double forth = 4.0){ cout << "Base1::" << __FUNCTION__ << " char*, double=, double=, double= " <<endl; }
    explicit Base1 (string zero = string("")){ cout << "Base1::" << __FUNCTION__ <<" string= "  << endl;}
    Base1(char first, int second){ cout << "Base1::" << __FUNCTION__ << " char, int " <<endl; }
    Base1(char first, double second){ cout << "Base1::" << __FUNCTION__ << " char, double " <<endl; }
    Base1(int zero, char* first, double second = 2.0, double third = 3.0, double forth = 4.0){ cout << "Base1::" << __FUNCTION__ << " int, char*, double=, double=, double= " <<endl; }
};


class Derive: public Base1
{
private:
   int d{ 0 }; //就会初始化派生类成员
public:
    using Base1::Base1;  //继承构造函数
};


class Base2
{
public:
    Base2(){cout << "Base2::" << __FUNCTION__ <<endl;}
    Base2(char first) { cout << "Base2::" << __FUNCTION__ << " char " <<endl; }
};

class Derive12: public Base1, Base2
{
private:
   int d{ 0 }; //就会初始化派生类成员
public:
    using Base1::Base1;  //继承构造函数
    using Base2::Base2;  //继承构造函数
    Derive12(){cout << "Derive12::" << __FUNCTION__  <<endl;}                   //消除二义性
    Derive12(char x){cout << "Derive12::" << __FUNCTION__ << " char " <<endl;}  //消除二义性

};

int main()
{
    Derive d0,                          //Base1::Base1 string=
           d1(string("hello")),         //Base1::Base1 string=
           d2(-1, nullptr),             //Base1::Base1 int, char*, double=, double=, double= 
           d3('0',1),                   //Base1::Base1 char, int
           d4('0', 1.0),                //Base1::Base1 char, double
           d5(0, nullptr, 1.0, 2.0),    //Base1::Base1 int, char*, double=, double=, double=
           d6(nullptr),                 //Base1::Base1 char*, double=, double=, double=
           d7('c');                     //Base1::Base1 char 
    Derive12 e0,                        //Base1::Base1 string=
                                        //Base2::Base2
                                        //Derive12::Derive12
             e1('x');                   //Base1::Base1 string= 
                                        //Base2::Base2
                                        //Derive12::Derive12 char 
    return 0;
}
```

### 虚继承
* 解决从不同途径继承来的同一基类，会在子类中存在多份拷贝的问题，避免浪费存储空间和二义性问题，对原本冗余的数据成员也只会初始化一次。
#### 实现原理
* 虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现。
* 每个虚继承的子类都有一个指向虚基类表（不占用类对象的存储空间，记录了虚基类与本类的偏移量）的虚基类表指针vbptr（占用一个指针的存储空间），通过虚基类表的偏移地址就找到了虚基类成员
* 当虚继承的类被当做父类继承时，虚基类指针也会被继承，且最终的子类中的虚基类表指针的个数和它所继承的虚继承的类的个数相同。
```cpp
// 64bit OS
class A{int a;};						//4
class B :virtual public A{int b;};		//16=4+4+8
class C :virtual public A{int c;};		//16=4+4+8
class D :public B, public C{int d;};	//40=16+16+4+4
```

#### NOTE
1. 在继承链顶部被虚继承的类被称为虚基类
2. 虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它**不影响派生类本身**。
3. 能用单一继承解决的问题就不要使用多继承
4. 在一个成员初始化列表中同时出现对虚基类和非虚基类构造函数的调用时，虚基类的构造函数先于非虚基类的构造函数执行。


# 关键字补充说明

## cv限定符

### const

+ const修饰的变量的可见范围为文件作用域

+ const变量的初始化可在编译期初始化，也可以在运行时初始化。

#### const与指针

+ 识别方法：const后面的是常量。`const type = type const`

### volatile

+ 含义：被volatile修饰的变量表明它可能被某些编译器未知的因素更改(操作系统、硬件或者其它线程等)。
+ 表现：编译器对访问该变量的代码不再进行优化；在运行时系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据，而且读取的数据立刻被保存。

#### 使用场景

1. 中断服务程序中修改的供其它程序检测的变量需要加 `volatile`
2. 并行设备的硬件寄存器
3. 多任务环境下各任务间共享的标志应该加 `volatile`；
4. 存储器映射的硬件寄存器通常也要加 `volatile` 说明，因为每次对它的读写都可能由不同意义；

## constexpr

### 背景

+ C++11为了解决`const`具有的只读和常量的双重语义造成的歧义问题，引入了`constexpr`来承接常量。
+ `const`和`constexpr`都可以修饰数据、函数、表达式，且大多场景下可以相互替代。

### constexpr使用要求

#### 对编译的影响

+ `constexpr`修饰的函数如果编译期可以确定就确定，否则的话函数成为普通函数。所以如果函数体适用于constexpr函数的条件，可以加上`constexpr`。
+ `constexpr`修饰的变量的值必须在编译时就能确定。

#### constexpr修饰函数/表达式

+ `constexpr`可以修饰函数模板，如果其实例化版本不满足`constexpr`则函数自动退化为普通函数。
+ `constexpr`函数隐式的声明为`const`函数。

1. 被修饰的函数必须在使用之前被定义。
2. 函数只有一条return语句(c++11要求，C++14放开)，`static_assert，using，typedef`等不会产生实际代码的语句在函数中可以使用。
3. 函数必须有返回值且必须是一个常量表达式(不能使用非常量表达式的函数，全局数据)。

#### constexpr修饰变量

+ `constexpr`修饰的变量类型只能是基本数据类型、指针、引用和自定义数据类型(需**满足要求**)，不能是其它标准库类型。且隐含要求了该变量为`const`类型。

1. 要求：自定义常量构造函数+构造函数空函数体+初始化列表由常量表达式赋值

   ```cpp
   class Point{
       public:
           constexpr Point( double x = 0, double y = 0 ): x_( x ), y_( y ){  }
       private:
           double x_, y_;
   };
   constexpr string str = "hello"; // error: constexpr variable cannot have non-literal type
   constexpr Point pt( 10, 20 ); // Evaluate at compiling time
   ```

# PIML(pointer to implementation)

1. 目的：通过使用指针的方式隐藏对象的实现细节，将文件间的编译依存关系降至最低的方法之一。
2. 实现原理：利用了前置申明。在C++语言中，要定义某个类型的变量或者使用类型的某个成员，就必须知道这个类的完整定义，其例外情况是：如果定义这个类型的指针，或者该类型是函数的参数或者返回类型(即使是传值类型的)，那么就可以通过前置声明引入这个类型的名字，而不需要提供暴露其完整的类型定义，从而类型的完整定义可以被隐藏在其他hpp头文件或者cpp实现文件中，而这个指针也被称为不透明指针(opaque pointer)。
3. 实现方法：在API的头文件中提供接口类的定义以及实现类的前置声明**接口类不能include实现类的头文件，否则白干**，实现类的本身定义和成员函数的实现都隐藏在cpp文件中去，同时为了避免实现类的符号污染外部名字空间，实现类大多作为接口类的内部嵌套类的形式。
4. 其他优点：信息隐蔽、加速编译、更好的二进制兼容性、惰性分配

# 重载、覆盖和改写(隐藏)

1. 重载**overload**：涉及的多方在**同一个作用域**中(同一类中或者都在全局作用域...)，且多方的函数名一定相同，函数参数列表一定不同，重载和被重载函数可以被virtual修饰也可以不被修饰。
2. 覆盖**override**：涉及的多方在**多个类中**，多方的函数名、参数列表以及返回值类型完全相同，基类的函数必须由virtual修饰，子类重写的方法可以加`override`关键字。**返回值类型可以不同**，此时不同是指函数返回本类类型的指针或者引用，这种情况称为**协变**。
3. 改写**overwrite**：涉及的多方在**多个作用域**，多方的函数名一定相同，参数列表不一定相同，也无论基类函数是否被virtual修饰。

+ 被隐藏的函数无法通过子类调用到，即使实参数列表完全匹配被隐藏函数的形式参数列表。

+ |                   | 重载overload |               覆盖override                |      改写overwrite/隐藏      |
  | :---------------: | :----------: | :---------------------------------------: | :--------------------------: |
  |    **关键字**     |      无      |                 override                  |              无              |
  |    **作用域**     |  同一作用域  |                继承类之间                 |          多个作用域          |
  |   **方法参数**    |     不同     |                 完全相同                  |          可同可不同          |
  | **virtual关键字** |   可有可无   |                父类必须有                 | 可有可无(和覆盖冲突则为覆盖) |
  |  **返回值类型**   |  可同可不同  | 一般相同（不同：协变,返回this指针或引用） |          可同可不同          |
  |     **作用**      |   静态多态   |                 动态多态                  |     屏蔽其他作用域的影响     |

# 异常处理
* C++处理异常的机制是由检查(try)、抛出(throw)和捕捉(catch)3个部分组成
* 当异常被正确捕捉后，所有从try到throw语句之间构造起来的对象的析构函数将被自动调用。否则当系统调用terminate()终止整个程序，这种情况下不能保证所有局部对象会被正确地销毁。
## catch块
* Catch块可以任何顺序排列，异常处理的顺序是首先进入与异常类型匹配且离抛出异常位置最近的那一个。
* catch块仅通过类型而不是通过值来匹配的，所以catch块的参数可以没有参数名称，只需要参数类型。
* 如果程序抛出的异常没有对应类型的catch块捕捉处理，默认将会把这种异常交给unexpected()函数处理。
* catch块不能访问try块中定义的变量
### catch块支持的类型转换

1. 非常量转换到常量的类型转换
2. 派生类到基类的转换
3. 数组被转换成为指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针（降级问题）
4. 标准算术类型的转换和类类型转换(使用类的类型转换运算符和转换构造函数)。
## throw
* throw先通过Copy构造函数构造一个新对象，再把该新对象传递给 catch. 
* 异常抛出的新对象并非创建在函数栈上，而是创建在专用的异常栈上，因此它才可以跨接多个函数而传递到上层
## 函数的异常声明列表
* C++ 允许在函数声明和定义时，在函数的()后方加上throw关键字和它所能拋出的异常类型列表。如果不写则表示可以抛出任意类型的异常，列表为空代表不会抛出异常。
## 异常种类
### 标准异常
*  标准异常都是从类`exception`中派生的类，都含有方法`what()`用以以字符串形式显式异常信息。
![](./img/lang/exception.jpg)

### 自定义异常
* 需要从标准异常中继承

# 线程和原子操作

## 线程 thread

### 线程创建

+ 借助thread()函数构造线程对象用于启动线程，线程对象包含线程函数、线程栈、线程起始状态、以及线程ID等运行时上下文信息

1. 函数、函数对象、lambda表达式都可用于创建线程。

### 线程结束

#### 绑定式 join()

+ 在join()调用处阻塞父线程直到子进程结束，此时子进程所拥有的资源将会被收回，进程对象不可再被重新绑定

#### 分离式 detach()

+ 将子进程中从父进程分离出来并将其所有权和控制权交给C++运行库，此时父进程不能与子进程交互，运行库保证子线程的资源会在结束时被正确处理。

## 原子操作 atomic

+ 背景：解决再含有写请求的多个操作下使用锁造成的阻塞和低效的问题，避免锁控制不合理导致的死锁

### 内置原子操作类型

+ 默认提供了内置数据类型(`bool、*char、*int`等整数类型)的原子操作支持

# C++其它部分新特性

## C++ 11

### tuple容器(CPP11)

+ 作用：提供一个可以存储多种多个类型的值的一中泛型容器类。
+ 对`tuple<>`类型的访问有两种方式。一种是`std::get<index>(obj)`方法，一种是`std::tie(varname...) = var`方法。前者需要提供所需成员在tuple中的下标index，后者括号内的varname都必须提前申明。

### decltype后置返回类型

+ `auto function_name(Args...) -> decltype`(返回类型计算表达式);

### 新初始化机制

#### [就地初始化](#就地初始化)

#### [列表初始化](#列表初始化list\_initialization)

#### [委托构造函数](#委托构造函数)

### 外部模板(CPP11)

+ 背景：模板函数在不同的编译单元可能被同一个类型实例化多次造成代码膨胀(链接时是随机选取一个实例化后的模板)。
+ 形式:`extern template [class] function_name/class_name<实例化的类型>[(Args...)]`;
+ 显式告诉编译器何时进行模板的实例化，上式的意思是告知编译器此时不要实例化，实例化已经在其它地方实现。

### 编译时的多重尖括号

### using定义类型别名

+ `using NewType = Old/CertainType`

### nullptr

+ 引入`nullptr`用来初始化所有指针类型变量

## C++14

### auto实现返回类型自动推导

+ `auto function_name(Args...);`

### lambda表达式

1. 通用捕获：带有初始化器的捕获符，实例：`[x = 1]{ return x; // 1 }`
2. 使用通用捕获捕获仅可移动的类型，实例：`unique\_ptr<T> x = ...; [u=move(u)] {  do\_something\_with( u );}`
3. 泛型lambda表达式：参数可以使用自动推断类型的功能，而不需要显示地声明具体类型。
4. 表达式捕捉：允许用任何类型的表达式初始化捕捉的变量(与1，2相关)。

## C++17

### 结构化绑定(CPP17)

+ 形式：类似于python中对返回值的直接分片。`auto [x,y,z] = obj_var;`方括号内为结构化绑定后的变量的名称，其中auto可以与cv限定符、引用组合表达不同的绑定方法。
+ 作用：方便了代码的编写，在一些场景下可以替换tuple。方便对被绑定结构的访问(例如对map中key-value的访问，处理多返回值函数等)。
+ 重要原则：结构化绑定的本意是一个绑定而非申明，任何违反这一原则的写法都是不被编译器允许的

#### 绑定方式(所声明的变量的形式)

+ 可绑定部分：数组、array、pair、tuple的各个元素。实体的非静态public数据成员且被绑定成员不能分散在多个类中。

1. 非引用：此时各个变量是被绑定变量中可以被绑定的各个属性的拷贝。
2. 引用：各个变量绑定的是被绑定变量中可以被绑定部分的本身。

# 强烈推荐用[网站](https://cppinsights.io/)翻译代码，验证自己的想法

+ 尤其是auto、decltype、lambda等一些章节
